{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Platform Engineering Guide","text":"<p>Jak zbudowa\u0107 produkcyjn\u0105 platform\u0119 cloud od zera \u2014 krok po kroku, bez pomijania trudnych decyzji.</p>"},{"location":"#co-znajdziesz-w-tym-przewodniku","title":"Co znajdziesz w tym przewodniku","text":"<p>Kompletny walkthrough budowania platformy na Google Cloud Platform, w pe\u0142ni zautomatyzowanej przez Infrastructure as Code i CI/CD bez kluczy serwisowych.</p> <pre><code>[U\u017cytkownik] \u2192 Cloudflare CDN \u2192 GCS bucket (SPA)\n                                      \u2502 JWT\n                                      \u25bc\n                              API Gateway (walidacja JWT)\n                                      \u2502 OIDC\n                                      \u25bc\n                              Cloud Run (FastAPI)\n                                      \u2502 VPC\n                                      \u25bc\n                              Firestore\n\nGitHub Actions (WIF, keyless) \u2192 deploy ca\u0142ej infrastruktury\n</code></pre> <p>Stos: Terraform \u00b7 Google Cloud Run \u00b7 API Gateway \u00b7 Identity Platform \u00b7 Firestore \u00b7 GCS \u00b7 Cloudflare CDN \u00b7 GitHub Actions (WIF)</p> <p>Koszt: ~$7\u20138/mies (praktycznie tylko VPC Connector \u2014 ca\u0142a reszta mie\u015bci si\u0119 w Free tier)</p>"},{"location":"#rozdziay","title":"Rozdzia\u0142y","text":"FundamentyWarstwa aplikacyjnaAutomatyzacja i operacje Rozdzia\u0142 Tematyka Bootstrap \u2014 keyless CI/CD Workload Identity Federation, zero kluczy SA, separacja warstw TF Sie\u0107 \u2014 VPC i izolacja VPC, firewall deny-all, VPC Connector, IAM vs sieciowa izolacja Rozdzia\u0142 Tematyka Backend \u2014 Cloud Run + FastAPI Kontener, Artifact Registry, JWT decode, chicken-and-egg deploy Auth \u2014 Identity Platform + JWT Google SSO, Firebase SDK, JWT flow, pu\u0142apki API Gateway OpenAPI spec, CORS preflight, walidacja JWT, google-beta Baza danych \u2014 Firestore NoSQL vs SQL, 1 zas\u00f3b TF, model danych, free tier Frontend \u2014 GCS + Cloudflare CDN CNAME trick, SPA routing, cache-control Rozdzia\u0142 Tematyka CI/CD \u2014 GitHub Actions deploy.yml, SHA tagging, auto-deploy per branch Staging Multi-env, suffix pattern, branch\u2192env mapping Monitoring Dashboard, alert policies, billing budget jako kod Security Review IAM checklist, \u015bwiadome kompromisy Analiza koszt\u00f3w Free tier, por\u00f3wnanie z alternatywami"},{"location":"#zacznij-tutaj","title":"Zacznij tutaj","text":"<p>Je\u015bli zaczynasz od zera:</p> <p>Wymagania wst\u0119pne \u2192 Czego si\u0119 nauczysz \u2192</p>"},{"location":"guide/00-intro/","title":"Czego si\u0119 nauczysz","text":"<p>Ten przewodnik pokazuje, jak od zera zbudowa\u0107 produkcyjn\u0105 platform\u0119 cloud na Google Cloud Platform \u2014 bez klikania w konsoli, bez kluczy serwisowych w kodzie, bez r\u0119cznych krok\u00f3w przy ka\u017cdym deployu.</p>"},{"location":"guide/00-intro/#co-zbudujemy","title":"Co zbudujemy","text":"<p>Kompletna platforma webowa z backendem, frontendem, baz\u0105 danych, uwierzytelnianiem i monitoringiem \u2014 w pe\u0142ni zautomatyzowana, z oddzielnym \u015brodowiskiem staging.</p> <pre><code>[U\u017cytkownik] \u2192 HTTPS \u2192 [Cloudflare CDN]\n                              \u2502\n                              \u25bc\n                    [GCS Bucket \u2014 SPA]\n                              \u2502 fetch() + JWT\n                              \u25bc\n                    [API Gateway] \u2190 walidacja JWT (Identity Platform)\n                              \u2502 OIDC token\n                              \u25bc\n                    [Cloud Run \u2014 FastAPI] \u2190 ingress tylko od API GW (IAM)\n                              \u2502 przez VPC\n                              \u25bc\n                    [Firestore] \u2190 zerowy koszt przy braku ruchu\n\n[GitHub Actions] \u2192 WIF (bez kluczy) \u2192 deploy ca\u0142ej infrastruktury\n[Cloud Monitoring] \u2192 dashboard + alerty \u2192 email\n</code></pre>"},{"location":"guide/00-intro/#stos-technologiczny","title":"Stos technologiczny","text":"Warstwa Technologia Dlaczego Infrastruktura jako kod Terraform v1.5+ Powtarzalny, wersjonowany, idempotentny Compute Google Cloud Run Skaluje do 0 \u2014 zerowy koszt przy braku ruchu Auth Identity Platform + Firebase Auth Google SSO out-of-the-box, JWT managed API Google Cloud API Gateway Walidacja JWT przed backendem, OpenAPI spec Baza danych Firestore Zerowy koszt baseline, brak konfiguracji sieci Frontend GCS bucket + Cloudflare CDN ~$0/mies, custom domena, DDoS protection CI/CD GitHub Actions + WIF Keyless auth \u2014 zero sekret\u00f3w z kluczami SA Monitoring Cloud Monitoring Natywna integracja, alerty jako kod TF Sie\u0107 VPC + Serverless Connector Izolacja backendu od publicznego internetu"},{"location":"guide/00-intro/#architektura-decyzji-adr-driven","title":"Architektura decyzji (ADR-driven)","text":"<p>Ka\u017cda nieoczywista decyzja jest udokumentowana jako ADR (Architecture Decision Record) \u2014 z kontekstem, alternatywami i uzasadnieniem. Znajdziesz je w <code>docs/adr/</code>. To nie jest dokumentacja \"co zrobili\u015bmy\", tylko \"dlaczego tak, a nie inaczej\".</p> <p>Przyk\u0142ady decyzji, kt\u00f3re mog\u0142yby p\u00f3j\u015b\u0107 inaczej:</p> Decyzja Wybrali\u015bmy Odrzucili\u015bmy Pow\u00f3d Compute Cloud Run GKE Autopilot GKE: $70/mies baseline, overkill dla prototypu CDN Cloudflare Free Google Global LB Google LB: $23/mies, Cloudflare: $0 Auth CI/CD Workload Identity Federation Service Account keys Klucze SA to wektory ataku \u2014 WIF eliminuje problem Baza Firestore Cloud SQL SQL: $7/mies zawsze; Firestore: $0 przy braku ruchu API security IAM + JWT Network ingress rules IAM daje lepsz\u0105 izolacj\u0119 przy tym stosie"},{"location":"guide/00-intro/#jak-czytac-ten-przewodnik","title":"Jak czyta\u0107 ten przewodnik","text":"<p>Rozdzia\u0142y s\u0105 u\u0142o\u017cone w kolejno\u015bci implementacji. Ka\u017cdy rozdzia\u0142 zawiera:</p> <ul> <li>Kontekst \u2014 co budujemy i dlaczego w tej kolejno\u015bci</li> <li>Kod \u2014 pliki Terraform i konfiguracje z komentarzami</li> <li>Pu\u0142apki \u2014 rzeczywiste b\u0142\u0119dy napotkane podczas budowania (nie hipotetyczne)</li> <li>Alternatywy \u2014 co odrzucili\u015bmy i dlaczego</li> </ul> <p>Senior thinking</p> <p>Pu\u0142apki i odrzucone alternatywy to najcenniejsza cz\u0119\u015b\u0107. Ka\u017cdy mo\u017ce skopiowa\u0107 dzia\u0142aj\u0105cy kod \u2014 zrozumienie dlaczego tak, a nie inaczej, to jest to, co odr\u00f3\u017cnia architekta od copy-paste engineera.</p>"},{"location":"guide/00-intro/#szacowany-koszt-platformy","title":"Szacowany koszt platformy","text":"Komponent Koszt/mies Uwagi Cloud Run ~$0 Skaluje do 0; przy ruchu: $0.00002400/vCPU-sec API Gateway ~$0 Free tier: 2M calls/mies Firestore ~$0 Free tier: 1 GB storage, 50k reads/dzie\u0144 GCS bucket ~$0.02 0.026 USD/GB/mies Cloudflare CDN $0 Free tier bez limitu bandwidth VPC Connector ~$7 Sta\u0142y koszt nawet przy 0 req \u2014 najwi\u0119kszy koszt Cloud Monitoring $0 Free tier: 150 MB metryk/mies \u0141\u0105cznie ~$7\u201310/mies Praktycznie tylko VPC Connector <p>VPC Connector to \u015bwiadoma decyzja \u2014 izoluje backend sieciowo. Bez niego koszt = ~$0.</p>"},{"location":"guide/01-prerequisites/","title":"Wymagania wst\u0119pne","text":"<p>Zanim zaczniesz, musisz mie\u0107 dost\u0119p do kilku zewn\u0119trznych serwis\u00f3w i lokalnie zainstalowane narz\u0119dzia. Ten rozdzia\u0142 jest kr\u00f3tki \u2014 wr\u00f3\u0107 do niego gdy napotkasz b\u0142\u0105d \"command not found\".</p>"},{"location":"guide/01-prerequisites/#konta-zewnetrzne","title":"Konta zewn\u0119trzne","text":"Serwis Wymagane Po co Google Cloud Konto z billing account Projekt GCP, wszystkie zasoby GitHub Konto + org lub user Repo, Actions, Secrets Cloudflare Konto z domen\u0105 CDN, SSL, DNS dla frontendu <p>Billing account</p> <p>Musisz mie\u0107 aktywne konto rozliczeniowe GCP. Free tier nie wystarczy \u2014 Cloud Run, VPC Connector i API Gateway wymagaj\u0105 w\u0142\u0105czonego billing (nawet je\u015bli koszty s\u0105 $0). Uruchom: <pre><code>gcloud beta billing accounts list\n</code></pre> Je\u015bli puste \u2014 dodaj kart\u0119 w console.cloud.google.com/billing.</p>"},{"location":"guide/01-prerequisites/#narzedzia-lokalne","title":"Narz\u0119dzia lokalne","text":"<pre><code># Sprawd\u017a co ju\u017c masz\nterraform version    # wymaga &gt;= 1.5.0\ngcloud version       # Google Cloud SDK\ngh version           # GitHub CLI\ndocker version       # Docker Engine\ngit version\n</code></pre>"},{"location":"guide/01-prerequisites/#instalacja-macos","title":"Instalacja (macOS)","text":"<pre><code>brew install terraform google-cloud-sdk gh docker git\n</code></pre>"},{"location":"guide/01-prerequisites/#instalacja-linuxdebian","title":"Instalacja (Linux/Debian)","text":"Terraformgcloud CLIGitHub CLI <pre><code>wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | \\\n  sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg &gt; /dev/null\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] \\\n  https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | \\\n  sudo tee /etc/apt/sources.list.d/hashicorp.list\nsudo apt update &amp;&amp; sudo apt install terraform\n</code></pre> <pre><code>curl https://sdk.cloud.google.com | bash\nexec -l $SHELL\ngcloud init\n</code></pre> <pre><code>sudo apt install gh\ngh auth login\n</code></pre>"},{"location":"guide/01-prerequisites/#konfiguracja-lokalna","title":"Konfiguracja lokalna","text":""},{"location":"guide/01-prerequisites/#1-uwierzytelnienie-gcloud","title":"1. Uwierzytelnienie gcloud","text":"<pre><code>gcloud auth login\ngcloud auth application-default login  # (1)\n</code></pre> <ol> <li>Application Default Credentials (ADC) \u2014 u\u017cywane przez Terraform lokalnie. Bez tego <code>terraform plan</code> zwr\u00f3ci b\u0142\u0105d autentykacji.</li> </ol>"},{"location":"guide/01-prerequisites/#2-github-cli","title":"2. GitHub CLI","text":"<pre><code>gh auth login\n# Wybierz: GitHub.com \u2192 HTTPS \u2192 Authenticate with browser\n</code></pre>"},{"location":"guide/01-prerequisites/#3-weryfikacja-uprawnien-gcp","title":"3. Weryfikacja uprawnie\u0144 GCP","text":"<p>Potrzebujesz uprawnie\u0144 na poziomie organizacji (do tworzenia projekt\u00f3w) lub przynajmniej prawa do tworzenia projektu w folderze.</p> <pre><code>gcloud organizations list\n# Powinna pojawi\u0107 si\u0119 twoja org z ID\n</code></pre> <p>Je\u015bli pusta \u2014 skontaktuj si\u0119 z adminem GCP. Projekt mo\u017cesz te\u017c tworzy\u0107 bez organizacji, ale stracisz hierarchi\u0119 uprawnie\u0144.</p>"},{"location":"guide/01-prerequisites/#struktura-repo","title":"Struktura repo","text":"<p>Po wykonaniu bootstrapu repo b\u0119dzie wygl\u0105da\u0107 tak:</p> <pre><code>.\n\u251c\u2500\u2500 scripts/\n\u2502   \u251c\u2500\u2500 run.sh                 # entry point \u2014 generuje project ID i odpala bootstrap\n\u2502   \u251c\u2500\u2500 bob_budowniczy.sh      # 7-etapowy idempotentny bootstrap\n\u2502   \u2514\u2500\u2500 cleanup.sh             # usuwa wszystko (nieodwracalne)\n\u251c\u2500\u2500 tf/\n\u2502   \u251c\u2500\u2500 bootstrap/             # WIF, Service Accounts \u2014 tylko lokalnie\n\u2502   \u251c\u2500\u2500 infra/                 # VPC, subnet, firewall\n\u2502   \u251c\u2500\u2500 backend/               # Cloud Run, Artifact Registry, VPC Connector\n\u2502   \u251c\u2500\u2500 auth/                  # Identity Platform, Google SSO\n\u2502   \u251c\u2500\u2500 api-gateway/           # API Gateway, OpenAPI spec\n\u2502   \u251c\u2500\u2500 database/              # Firestore\n\u2502   \u251c\u2500\u2500 frontend/              # GCS buckets\n\u2502   \u2514\u2500\u2500 monitoring/            # Cloud Monitoring dashboard + alerty\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 main.py                # FastAPI backend\n\u2502   \u251c\u2500\u2500 requirements.txt\n\u2502   \u2514\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 frontend/\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 app.js\n\u251c\u2500\u2500 .github/\n\u2502   \u2514\u2500\u2500 workflows/\n\u2502       \u251c\u2500\u2500 deploy.yml          # r\u0119czny deploy TF (wszystkie warstwy)\n\u2502       \u251c\u2500\u2500 deploy-backend.yml  # auto-deploy po push do app/\n\u2502       \u2514\u2500\u2500 deploy-frontend.yml # auto-deploy po push do frontend/\n\u2514\u2500\u2500 docs/\n    \u251c\u2500\u2500 adr/                    # Architecture Decision Records\n    \u2514\u2500\u2500 guide/                  # ten przewodnik\n</code></pre> <p>Warstwy Terraform</p> <p>Ka\u017cda warstwa (<code>tf/&lt;nazwa&gt;/</code>) ma w\u0142asny stan Terraform w osobnym prefiksie GCS. Mo\u017cesz deployowa\u0107 je niezale\u017cnie \u2014 zmiana w <code>tf/frontend/</code> nie dotyka stanu <code>tf/backend/</code>. To kluczowa decyzja architektoniczna (separacja odpowiedzialno\u015bci + bezpiecze\u0144stwo stanu).</p>"},{"location":"guide/02-bootstrap/","title":"Bootstrap \u2014 keyless CI/CD","text":"<p>Bootstrap to najtrudniejsza cz\u0119\u015b\u0107 projektu koncepcyjnie \u2014 musisz zbudowa\u0107 maszyn\u0119, kt\u00f3ra zbuduje wszystko inne, zanim ta maszyna istnieje. Robimy to raz, lokalnie, i nigdy wi\u0119cej do tego nie wracamy.</p>"},{"location":"guide/02-bootstrap/#problem-jak-cicd-uwierzytelnia-sie-do-gcp","title":"Problem: jak CI/CD uwierzytelnia si\u0119 do GCP?","text":"<p>Tradycyjne podej\u015bcie: wygeneruj klucz Service Account (JSON), wrzu\u0107 do GitHub Secrets, u\u017cyj w Actions.</p> <p>Dlaczego to z\u0142e:</p> <ul> <li>Klucz ma wa\u017cno\u015b\u0107 do r\u0119cznego usuni\u0119cia \u2014 je\u015bli wycieknie (GitHub breach, logi, commit), atakuj\u0105cy ma dost\u0119p przez lata</li> <li>Rotacja kluczy jest r\u0119czna i cz\u0119sto pomijana</li> <li>JSON key to wektor ataku #1 w GCP wed\u0142ug Google Security</li> </ul> <p>Nasze podej\u015bcie: Workload Identity Federation (WIF)</p> <pre><code>GitHub Actions Runner\n        \u2502\n        \u2502 1. prosi GitHub o OIDC token (JWT)\n        \u25bc\nGitHub OIDC Provider\n        \u2502 2. wystawia token z claims: repo, branch, sha\n        \u25bc\nGoogle Cloud STS\n        \u2502 3. weryfikuje token (Google ufa GitHub OIDC)\n        \u2502 4. sprawdza attribute_condition: repository == 'benhornbeam/repo'\n        \u25bc\nService Account Token (kr\u00f3tkoterminowy, 1h)\n        \u2502 5. tylko gh-infra-worker SA mo\u017ce by\u0107 impersonowany\n        \u25bc\nZasoby GCP (Terraform plan/apply)\n</code></pre> <p>\u017baden klucz nigdzie nie istnieje. Token wa\u017cny 1 godzin\u0119. Tylko ten repo mo\u017ce impersonowa\u0107 ten SA.</p>"},{"location":"guide/02-bootstrap/#co-robi-bootstrap","title":"Co robi bootstrap","text":"<p>Dwa etapy: skrypt bash + warstwa Terraform.</p>"},{"location":"guide/02-bootstrap/#etap-1-bob_budowniczysh-bash-lokalnie","title":"Etap 1: <code>bob_budowniczy.sh</code> (bash, lokalnie)","text":"<p>7-etapowy idempotentny skrypt. \"Idempotentny\" = mo\u017cesz uruchomi\u0107 wielokrotnie bez skutk\u00f3w ubocznych \u2014 ka\u017cdy krok sprawdza czy zas\u00f3b ju\u017c istnieje.</p> <pre><code># Co robi skrypt w kolejno\u015bci:\n# 1. Tworzy prywatne repo na GitHubie\n# 2. Tworzy projekt GCP w organizacji\n# 3. Podpina billing account\n# 4. Aktywuje ~10 wymaganych API (IAM, Cloud Run, Artifact Registry, ...)\n# 5. Tworzy Bootstrap SA (tf-bootstrap-admin) z minimalnymi uprawnieniami\n# 6. Tworzy GCS bucket na stan Terraform\n# 7. Uruchamia `terraform plan` dla warstwy bootstrap\n</code></pre> <pre><code># Uruchomienie:\ncd scripts &amp;&amp; ./run.sh\n# run.sh auto-generuje project ID w formacie gcp-prototype-1-YYYYMMDD\n# i przekazuje do bob_budowniczy.sh\n</code></pre> <p>Pu\u0142apka: IAM propagation delay</p> <p>Po nadaniu roli SA, GCP potrzebuje ~30 sekund na propagacj\u0119. Skrypt ma wbudowane <code>sleep 30</code> po kluczowych operacjach IAM. Je\u015bli Terraform plan rzuca <code>Permission denied</code> chwil\u0119 po nadaniu roli \u2014 poczekaj minut\u0119 i spr\u00f3buj ponownie.</p>"},{"location":"guide/02-bootstrap/#etap-2-tfbootstrap-terraform-lokalnie","title":"Etap 2: <code>tf/bootstrap/</code> (Terraform, lokalnie)","text":"<p>Tworzy wszystko, co CI/CD potrzebuje do dzia\u0142ania.</p> <pre><code># tf/bootstrap/main.tf \u2014 uproszczony\n\n# Service Account dla GitHub Actions\nresource \"google_service_account\" \"github_sa\" {\n  account_id   = \"gh-infra-worker\"\n  display_name = \"GitHub Actions Infra Worker\"\n  project      = var.project_id\n}\n\n# Role \u2014 principle of least privilege\nresource \"google_project_iam_member\" \"worker_roles\" {\n  for_each = toset([\n    \"roles/compute.networkAdmin\",\n    \"roles/storage.admin\",\n    \"roles/run.admin\",\n    \"roles/artifactregistry.admin\",\n    \"roles/iam.securityAdmin\",        # (1)\n    \"roles/secretmanager.admin\",\n    \"roles/apigateway.admin\",\n    \"roles/monitoring.admin\",\n    # ... (pe\u0142na lista w tf/bootstrap/main.tf)\n  ])\n  project = var.project_id\n  role    = each.key\n  member  = \"serviceAccount:${google_service_account.github_sa.email}\"\n}\n</code></pre> <ol> <li><code>iam.securityAdmin</code> zamiast <code>projectIamAdmin</code> \u2014 ma <code>setIamPolicy</code>, ale w\u0119\u017cszy zakres. \u015awiadoma decyzja: u\u017cywamy w\u0119\u017cszej roli gdy tylko mo\u017cliwe.</li> </ol> <pre><code># WIF Pool \u2014 rejestruje GitHub jako zaufany issuer OIDC\nresource \"google_iam_workload_identity_pool\" \"github_pool\" {\n  workload_identity_pool_id = \"github-actions-pool-v3\"\n}\n\nresource \"google_iam_workload_identity_pool_provider\" \"github_provider\" {\n  workload_identity_pool_id          = google_iam_workload_identity_pool.github_pool.workload_identity_pool_id\n  workload_identity_pool_provider_id = \"github-provider\"\n\n  attribute_mapping = {\n    \"google.subject\"       = \"assertion.sub\"        # (1)\n    \"attribute.repository\" = \"assertion.repository\" # (2)\n  }\n\n  # Tylko ten repo mo\u017ce impersonowa\u0107 SA \u2014 bezpiecze\u0144stwo przez warunek\n  attribute_condition = \"assertion.repository == '${var.github_repo}'\"\n\n  oidc {\n    issuer_uri = \"https://token.actions.githubusercontent.com\"\n  }\n}\n</code></pre> <ol> <li><code>sub</code> = unikalny identyfikator workflow w GitHubie</li> <li>Mapujemy <code>repository</code> z tokenu GitHub \u2192 atrybut Google, \u017ceby u\u017cy\u0107 go w <code>attribute_condition</code></li> </ol> <pre><code># Binding: GitHub Actions Runner mo\u017ce impersonowa\u0107 gh-infra-worker\nresource \"google_service_account_iam_member\" \"wif_binding\" {\n  service_account_id = google_service_account.github_sa.name\n  role               = \"roles/iam.workloadIdentityUser\"\n  member = \"principalSet://iam.googleapis.com/${\n    google_iam_workload_identity_pool.github_pool.name\n  }/attribute.repository/${var.github_repo}\"\n}\n</code></pre>"},{"location":"guide/02-bootstrap/#jak-dziaa-w-github-actions","title":"Jak dzia\u0142a w GitHub Actions","text":"<pre><code># .github/workflows/deploy.yml \u2014 fragment\n\npermissions:\n  id-token: write   # (1) wymagane \u2014 bez tego Actions nie mo\u017ce pobra\u0107 OIDC token\n  contents: read\n\nsteps:\n  - name: Authenticate to Google Cloud\n    uses: google-github-actions/auth@v2\n    with:\n      workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}  # (2)\n      service_account: ${{ secrets.GCP_SA_EMAIL }}                 # (3)\n</code></pre> <ol> <li><code>id-token: write</code> \u2014 kluczowa linia. Bez niej GitHub nie udost\u0119pni OIDC tokenu jobowi.</li> <li>Format: <code>projects/NUMBER/locations/global/workloadIdentityPools/POOL/providers/PROVIDER</code></li> <li>Format: <code>gh-infra-worker@PROJECT_ID.iam.gserviceaccount.com</code></li> </ol> <p>Akcja <code>google-github-actions/auth</code> robi ca\u0142\u0105 wymian\u0119 tokenu automatycznie. Po tym kroku <code>gcloud</code> i Terraform maj\u0105 dost\u0119p przez ADC (Application Default Credentials).</p>"},{"location":"guide/02-bootstrap/#stan-terraform-separacja-warstw","title":"Stan Terraform: separacja warstw","text":"<p>Jeden bucket GCS, osobny prefiks per warstwa:</p> <pre><code>tf-state-gcp-prototype-1-20260224/\n\u251c\u2500\u2500 terraform/bootstrap/state/\n\u251c\u2500\u2500 terraform/infra/state/\n\u251c\u2500\u2500 terraform/backend/state/\n\u251c\u2500\u2500 terraform/auth/state/\n\u251c\u2500\u2500 terraform/api-gateway/state/\n\u251c\u2500\u2500 terraform/database/state/\n\u251c\u2500\u2500 terraform/frontend/state/\n\u2514\u2500\u2500 terraform/monitoring/state/\n</code></pre> <pre><code># tf/backend/provider.tf \u2014 przyk\u0142ad konfiguracji backendu\nterraform {\n  backend \"gcs\" {\n    # warto\u015bci przekazywane przez -backend-config (nie hardkodujemy project ID)\n    # bucket = \"tf-state-gcp-prototype-1-20260224\"\n    # prefix = \"terraform/backend/state\"\n  }\n}\n</code></pre> <pre><code># Init z dynamicznym konfiguracj\u0105\nterraform init \\\n  -backend-config=\"bucket=tf-state-${PROJECT_ID}\" \\\n  -backend-config=\"prefix=terraform/backend/state\"\n</code></pre> <p>Dlaczego osobne prefiksy, nie osobne buckety?</p> <p>Jeden bucket = jeden zas\u00f3b IAM do zarz\u0105dzania, jeden zas\u00f3b TF w bootstrapie, jedna polityka lifecycle. Osobne prefiksy = izolacja stan\u00f3w (Terraform nie widzi stanu innych warstw). Best of both worlds.</p>"},{"location":"guide/02-bootstrap/#puapki","title":"Pu\u0142apki","text":"<p>tf/bootstrap/ NIE deployuj przez CI/CD</p> <p>Warstwa bootstrap tworzy SA i WIF \u2014 czyli infrastruktur\u0119, kt\u00f3r\u0105 CI/CD u\u017cywa do uwierzytelnienia. Je\u015bli deployujesz bootstrap przez CI/CD, kt\u00f3re zale\u017cy od bootstrapu \u2192 b\u0142\u0119dne ko\u0142o. Bootstrap zawsze lokalnie, przez <code>tf-bootstrap-admin</code> SA z impersonacj\u0105 lub bezpo\u015brednio przez ADC jako owner projektu.</p> <p>Nowa rola dla gh-infra-worker \u2192 najpierw apply bootstrap</p> <p>Je\u015bli nowa warstwa TF potrzebuje roli, kt\u00f3rej <code>gh-infra-worker</code> jeszcze nie ma (np. <code>monitoring.admin</code> dla warstwy monitoring): 1. Dodaj rol\u0119 do <code>tf/bootstrap/main.tf</code> 2. <code>terraform apply</code> lokalnie dla bootstrapu 3. Dopiero potem deployuj now\u0105 warstw\u0119 przez CI</p> <p>Je\u015bli tego nie zrobisz, workflow wywali si\u0119 na <code>Permission denied</code> bez czytelnego komunikatu.</p> <p>State bucket: public_access_prevention = enforced</p> <p>Bucket ze stanem TF musi mie\u0107 <code>public_access_prevention = \"enforced\"</code>. Stan Terraform mo\u017ce zawiera\u0107 wra\u017cliwe informacje (endpointy, SA emails). Domy\u015blnie GCS bucket jest prywatny, ale warto to explicite ustawi\u0107 i sprawdzi\u0107 w security review.</p>"},{"location":"guide/02-bootstrap/#weryfikacja","title":"Weryfikacja","text":"<p>Po wykonaniu bootstrapu:</p> <pre><code># Sprawd\u017a czy WIF pool istnieje\ngcloud iam workload-identity-pools list \\\n  --location=global \\\n  --project=gcp-prototype-1-20260224\n\n# Sprawd\u017a role gh-infra-worker\ngcloud projects get-iam-policy gcp-prototype-1-20260224 \\\n  --flatten=\"bindings[].members\" \\\n  --filter=\"bindings.members:gh-infra-worker\" \\\n  --format=\"table(bindings.role)\"\n\n# Sprawd\u017a GitHub Secrets (powinny by\u0107 ustawione)\ngh secret list --repo benhornbeam/gcp-prototype-1-20260224\n# Oczekiwane: GCP_PROJECT_ID, GCP_WIF_PROVIDER, GCP_SA_EMAIL\n</code></pre> <p>Je\u015bli wszystko OK \u2014 masz CI/CD bez kluczy, gotowy do deployowania kolejnych warstw.</p>"},{"location":"guide/03-networking/","title":"Sie\u0107 \u2014 VPC i izolacja","text":"<p>Sie\u0107 jest zazwyczaj pierwsz\u0105 warstw\u0105 Terraform po bootstrapie \u2014 kolejne warstwy (backend, VPC Connector) do niej odwo\u0142uj\u0105 si\u0119 przez nazw\u0119.</p>"},{"location":"guide/03-networking/#cel-warstwy","title":"Cel warstwy","text":"<p>Izolacja backendu od publicznego internetu. Cloud Run ma <code>ingress=ALL</code> (wymagane przez API Gateway), ale przez VPC Connector wychodzi tylko do prywatnej sieci. U\u017cytkownicy nigdy nie docieraj\u0105 do Cloud Run bezpo\u015brednio.</p> <pre><code>Internet\n    \u2502 tylko port 443 \u2014 przez API Gateway\n    \u25bc\n[API Gateway] \u2192 IAM check \u2192 [Cloud Run ingress=ALL]\n                                     \u2502 VPC Connector egress\n                                     \u2502 (10.8.0.0/28)\n                                     \u25bc\n                              [prototype-vpc]\n                              subnet-warsaw: 10.0.1.0/24\n                                     \u2502 private_ip_google_access\n                                     \u25bc\n                              [Firestore / Secret Manager]\n                              (Google APIs bez publicznego IP)\n</code></pre>"},{"location":"guide/03-networking/#co-tworzy-warstwa-tfinfra","title":"Co tworzy warstwa <code>tf/infra/</code>","text":"<p>Trzy zasoby. To celowo ma\u0142a warstwa \u2014 fundament zmienia si\u0119 rzadko.</p> <pre><code># tf/infra/main.tf\n\n# VPC z wy\u0142\u0105czonym auto_create_subnetworks\nresource \"google_compute_network\" \"main_vpc\" {\n  name                    = \"prototype-vpc\"\n  auto_create_subnetworks = false  # (1)\n}\n\n# Podsie\u0107 w Warszawie \u2014 /24 = 254 adresy\nresource \"google_compute_subnetwork\" \"subnet_pl\" {\n  name          = \"subnet-warsaw\"\n  ip_cidr_range = \"10.0.1.0/24\"\n  region        = var.region          # europe-central2\n  network       = google_compute_network.main_vpc.id\n\n  private_ip_google_access = true     # (2)\n}\n\n# Jawna regu\u0142a deny-all \u2014 dokumentuje intent w kodzie\nresource \"google_compute_firewall\" \"deny_all_ingress\" {\n  name      = \"deny-all-ingress\"\n  network   = google_compute_network.main_vpc.name\n  priority  = 65534                   # (3)\n  direction = \"INGRESS\"\n\n  deny {\n    protocol = \"all\"\n  }\n\n  source_ranges = [\"0.0.0.0/0\"]\n}\n</code></pre> <ol> <li><code>auto_create_subnetworks = false</code> \u2014 bez tego GCP tworzy subsieci w ka\u017cdym regionie (default VPC). Utrudnia audyt sieci i zwi\u0119ksza ryzyko nieoczekiwanego egress mi\u0119dzy regionami.</li> <li><code>private_ip_google_access = true</code> \u2014 instancje bez publicznego IP mog\u0105 \u0142\u0105czy\u0107 si\u0119 z Google APIs (Firestore, Secret Manager, Artifact Registry). Bez tego musia\u0142by\u015b u\u017cywa\u0107 Cloud NAT lub publicznych IP dla ka\u017cdej maszyny w podsieci.</li> <li><code>priority = 65534</code> \u2014 GCP ma implicit deny-all na priorytecie 65535. Ta regu\u0142a (65534) jest o jeden wy\u017cej, ale jest eksplicytna \u2014 pojawia si\u0119 w audytach IAM, raportach compliance i <code>gcloud compute firewall-rules list</code>. Implicit regu\u0142y s\u0105 niewidoczne.</li> </ol>"},{"location":"guide/03-networking/#vpc-connector-acznik-cloud-run-z-vpc","title":"VPC Connector \u2014 \u0142\u0105cznik Cloud Run z VPC","text":"<p>VPC Connector tworzy si\u0119 w warstwie <code>tf/backend/</code>, ale koncepcyjnie jest cz\u0119\u015bci\u0105 sieci.</p> <pre><code># tf/backend/main.tf \u2014 fragment\n\nresource \"google_vpc_access_connector\" \"connector\" {\n  name           = \"backend-connector\"\n  network        = \"prototype-vpc\"\n  ip_cidr_range  = \"10.8.0.0/28\"   # (1)\n  region         = var.region        # europe-central2\n  min_throughput = 200               # Mbps (minimum reserved)\n  max_throughput = 300               # Mbps (maximum)\n}\n</code></pre> <ol> <li><code>/28</code> = 16 adres\u00f3w. VPC Connector potrzebuje dedykowanej podsieci, kt\u00f3ra nie nak\u0142ada si\u0119 na <code>subnet-warsaw</code> (10.0.1.0/24). U\u017cywamy <code>10.8.0.0/28</code> \u2014 inna pula RFC 1918.</li> </ol> <pre><code># Konfiguracja w Cloud Run service\nvpc_access {\n  connector = google_vpc_access_connector.connector.id\n  egress    = \"ALL_TRAFFIC\"  # (1)\n}\n</code></pre> <ol> <li><code>ALL_TRAFFIC</code> \u2014 ca\u0142y ruch wychodzi przez VPC, nie tylko RFC 1918. Alternatywa: <code>PRIVATE_RANGES_ONLY</code> \u2014 tylko ruch do prywatnych IP przez VPC, publiczny przez internet. Wybrali\u015bmy <code>ALL_TRAFFIC</code> dla pe\u0142nej izolacji i kontroli.</li> </ol>"},{"location":"guide/03-networking/#dlaczego-iam-zamiast-sieci-do-izolacji-cloud-run","title":"Dlaczego IAM zamiast sieci do izolacji Cloud Run?","text":"<p>Pierwotna architektura zak\u0142ada\u0142a <code>ingress=INTERNAL_LOAD_BALANCER</code>. Problem: API Gateway nie jest Load Balancerem w sensie GCP \u2014 nie mo\u017ce routowa\u0107 ruchu do Cloud Run z <code>ingress=INTERNAL</code>.</p> <p>Mo\u017cliwe rozwi\u0105zanie alternatywne: Private Service Connect (PSC) \u2014 bardziej zaawansowane, wymaga dodatkowej konfiguracji. Dla prototypu overengineering.</p> <p>Nasze rozwi\u0105zanie: <code>ingress=ALL</code> + izolacja przez IAM.</p> <pre><code>Atakuj\u0105cy z internetu\n    \u2502 pr\u00f3buje wywo\u0142a\u0107 Cloud Run URL bezpo\u015brednio\n    \u25bc\nCloud Run sprawdza IAM: czy caller ma roles/run.invoker?\n    \u2192 NIE (brak tokenu api-gateway-sa)\n    \u2192 403 Forbidden\n</code></pre> <p>Cloud Run jest technicznie dost\u0119pny z internetu, ale bez tokenu SA <code>api-gateway-sa</code> z rol\u0105 <code>roles/run.invoker</code> \u2014 ka\u017cde \u017c\u0105danie zwr\u00f3ci 403. To izolacja przez IAM, nie sieciowa. Dla compliance-heavy \u015brodowisk z PCI-DSS lub ISO 27001 \u2014 rozwa\u017c Private Service Connect lub <code>ingress=INTERNAL_LOAD_BALANCER</code> z Cloud Load Balancing.</p>"},{"location":"guide/03-networking/#puapki","title":"Pu\u0142apki","text":"<p>API Gateway \u2260 region VPC Connector</p> <p>API Gateway dzia\u0142a tylko w wybranych regionach. <code>europe-central2</code> (Warszawa) nie jest wspierany. Gateway musi by\u0107 w <code>europe-west1</code> (Belgia). VPC Connector i Cloud Run s\u0105 w <code>europe-central2</code>. Komunikacja mi\u0119dzy nimi idzie przez Google backbone \u2014 nie przez publiczny internet (~10ms dodatkowe op\u00f3\u017anienie).</p> <p>VPC Connector: sta\u0142y koszt ~$7/mies</p> <p>VPC Connector nalicza op\u0142at\u0119 nawet przy 0 requestach (<code>min_throughput = 200</code> Mbps = reserved capacity). To najwi\u0119kszy sta\u0142y koszt tej architektury. Bez VPC Connectora (np. Firestore przez publiczne API bezpo\u015brednio) \u2014 koszt infrastruktury = ~$0/mies.</p> <p>Firewall rules nie dotycz\u0105 Cloud Run</p> <p>Regu\u0142a <code>deny-all-ingress</code> nie wp\u0142ywa na Cloud Run. Cloud Run to us\u0142uga zarz\u0105dzana \u2014 dzia\u0142a poza VPC. Regu\u0142y firewall dotycz\u0105 zasob\u00f3w wewn\u0105trz VPC (Compute Engine, GKE nodes). VPC Connector jest bram\u0105 egress z Cloud Run do VPC, nie bram\u0105 ingress.</p>"},{"location":"guide/04-backend/","title":"Backend \u2014 Cloud Run + FastAPI","text":"<p>Cloud Run to serce platformy. Bezserwerowy kontener \u2014 p\u0142acisz za czas procesowania, nie za czas dzia\u0142ania. Przy 0 requestach: $0 koszt\u00f3w.</p>"},{"location":"guide/04-backend/#architektura-backendu","title":"Architektura backendu","text":"<pre><code>[GitHub: push do app/]\n         \u2502\n         \u25bc\n[GitHub Actions: deploy-backend.yml]\n  docker build \u2192 tag :SHA\n  docker push \u2192 Artifact Registry (europe-central2)\n         \u2502\n         \u25bc\n  gcloud run deploy backend-api --image=...:SHA\n         \u2502\n         \u25bc\n[Cloud Run v2 Service: backend-api]\n  ingress = ALL (API Gateway wymaga)\n  IAM: tylko api-gateway-sa ma roles/run.invoker\n  SA: cloud-run-backend-sa\n      \u2192 roles/logging.logWriter\n      \u2192 roles/datastore.user\n  VPC Connector \u2192 prototype-vpc \u2192 Firestore\n  scaling: min=0, max=3\n</code></pre>"},{"location":"guide/04-backend/#dockerfile","title":"Dockerfile","text":"<pre><code>FROM python:3.12-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8080\"]\n</code></pre> <p>Port <code>8080</code> \u2014 wymagany przez Cloud Run (domy\u015blny <code>containerPort</code>). <code>python:3.12-slim</code> zamiast <code>python:3.12</code> \u2014 mniejszy obraz (~150MB vs ~1GB), kr\u00f3tszy pull przy cold start.</p>"},{"location":"guide/04-backend/#fastapi-appmainpy","title":"FastAPI \u2014 <code>app/main.py</code>","text":""},{"location":"guide/04-backend/#konfiguracja-per-srodowisko","title":"Konfiguracja per \u015brodowisko","text":"<pre><code>import os\n\n# Env var ustawiana przez Cloud Run \u2014 r\u00f3\u017cna dla prod i staging\nENV = os.getenv(\"ENV\", \"prod\")\nCOLLECTION_PREFIX = \"staging_\" if ENV == \"staging\" else \"\"  # (1)\nALLOWED_ORIGINS = (\n    [\"https://staging.kamilos.xyz\"] if ENV == \"staging\"\n    else [\"https://app.kamilos.xyz\"]\n)\n</code></pre> <ol> <li>Ten sam obraz Docker dla prod i staging. R\u00f3\u017cnica: env var <code>ENV</code>. Nie duplikujemy kodu, nie tworzymy osobnych obraz\u00f3w.</li> </ol>"},{"location":"guide/04-backend/#cors-middleware","title":"CORS Middleware","text":"<pre><code>app.add_middleware(\n    CORSMiddleware,\n    allow_origins=ALLOWED_ORIGINS,    # (1)\n    allow_methods=[\"GET\", \"POST\"],\n    allow_headers=[\"Authorization\", \"Content-Type\"],\n)\n</code></pre> <ol> <li><code>allow_origins</code> jest list\u0105 konkretnych domen, nie <code>[\"*\"]</code>. Zbyt liberalne CORS to cz\u0119sty b\u0142\u0105d bezpiecze\u0144stwa \u2014 przegl\u0105darka blokowa\u0142aby requesty dla SPA z <code>kamilos.xyz</code> przy <code>*</code> i tak nie pomog\u0142oby, ale wildcard otwiera inne wektory ataku.</li> </ol>"},{"location":"guide/04-backend/#decode-jwt-bez-weryfikacji-podpisu","title":"Decode JWT bez weryfikacji podpisu","text":"<pre><code>def decode_jwt(authorization: str) -&gt; dict:\n    \"\"\"Dekoduje payload JWT bez weryfikacji podpisu.\n\n    API Gateway ju\u017c zweryfikowa\u0142 podpis przed przekazaniem requestu.\n    Tu potrzebujemy tylko payload (email, uid) \u2014 nie weryfikujemy ponownie.\n    \"\"\"\n    try:\n        token = authorization.split(\" \")[1]      # \"Bearer &lt;jwt&gt;\" \u2192 \"&lt;jwt&gt;\"\n        payload = token.split(\".\")[1]             # header.PAYLOAD.signature\n        payload += \"=\" * (4 - len(payload) % 4)  # base64url padding fix\n        return json.loads(base64.b64decode(payload))\n    except Exception:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n</code></pre> <p>To \u015bwiadoma decyzja: API Gateway wykonuje pe\u0142n\u0105 walidacj\u0119 JWT (podpis HMAC, expiry, issuer, audience). Backend jest chroniony IAM \u2014 tylko <code>api-gateway-sa</code> mo\u017ce go wywo\u0142a\u0107, wi\u0119c request bez poprawnego JWT nigdy do backendu nie dotrze. Duplikowanie kryptograficznej weryfikacji to overengineering.</p>"},{"location":"guide/04-backend/#endpointy","title":"Endpointy","text":"<pre><code>@app.post(\"/api\")\ndef api_post(authorization: str = Header(None)):\n    claims = decode_jwt(authorization)\n\n    # Hierarchia kolekcji: logins/{uid}/events/{auto_id}\n    db.collection(f\"{COLLECTION_PREFIX}logins\") \\\n      .document(claims[\"sub\"]) \\\n      .collection(\"events\") \\\n      .add({\n          \"timestamp\": datetime.now(timezone.utc),\n          \"email\":     claims.get(\"email\", \"\"),\n          \"name\":      claims.get(\"name\", \"\"),\n      })\n    return {\"status\": \"ok\"}\n\n\n@app.get(\"/api\")\ndef api_get(authorization: str = Header(None)):\n    claims = decode_jwt(authorization)\n\n    # Ostatnie 5 logowa\u0144, posortowane malej\u0105co\n    events = (\n        db.collection(f\"{COLLECTION_PREFIX}logins\")\n          .document(claims[\"sub\"])\n          .collection(\"events\")\n          .order_by(\"timestamp\", direction=firestore.Query.DESCENDING)\n          .limit(5)\n          .stream()\n    )\n    return {\n        \"user\": claims.get(\"email\", claims[\"sub\"]),\n        \"last_logins\": [\n            {\"timestamp\": e.to_dict()[\"timestamp\"].isoformat(),\n             \"email\":     e.to_dict().get(\"email\", \"\")}\n            for e in events\n        ],\n    }\n</code></pre>"},{"location":"guide/04-backend/#terraform-warstwa-tfbackend","title":"Terraform \u2014 warstwa <code>tf/backend/</code>","text":""},{"location":"guide/04-backend/#artifact-registry","title":"Artifact Registry","text":"<pre><code>resource \"google_artifact_registry_repository\" \"backend_repo\" {\n  repository_id = \"backend\"\n  format        = \"DOCKER\"\n  location      = var.region  # europe-central2\n}\n</code></pre> <p>AR zamiast Docker Hub: obrazy w tym samym regionie co Cloud Run \u2192 pull szybszy i bezp\u0142atny (brak egress mi\u0119dzy regionami). AR integruje si\u0119 z <code>gcloud auth</code> \u2014 nie potrzebujesz osobnych credentials dla Docker.</p>"},{"location":"guide/04-backend/#service-account-dla-cloud-run-runtime","title":"Service Account dla Cloud Run runtime","text":"<pre><code>resource \"google_service_account\" \"cloud_run_sa\" {\n  account_id = \"cloud-run-backend-sa\"\n}\n\n# Minimalny zestaw r\u00f3l \u2014 tylko co potrzebne\nresource \"google_project_iam_member\" \"run_sa_logging\" {\n  role   = \"roles/logging.logWriter\"  # logi do Cloud Logging\n  member = \"serviceAccount:${google_service_account.cloud_run_sa.email}\"\n}\n\n# roles/datastore.user przyznawany w tf/database/main.tf\n# \u2014 warstwa database zarz\u0105dza swoimi uprawnieniami IAM\n</code></pre>"},{"location":"guide/04-backend/#cloud-run-service","title":"Cloud Run Service","text":"<pre><code>resource \"google_cloud_run_v2_service\" \"backend\" {\n  name     = \"backend-api\"\n  location = var.region\n  ingress  = \"INGRESS_TRAFFIC_ALL\"  # (1)\n\n  template {\n    service_account = google_service_account.cloud_run_sa.email\n\n    containers {\n      image = var.image         # (2)\n      ports { container_port = 8080 }\n    }\n\n    vpc_access {\n      connector = google_vpc_access_connector.connector.id\n      egress    = \"ALL_TRAFFIC\"\n    }\n\n    scaling {\n      min_instance_count = 0   # (3)\n      max_instance_count = 3\n    }\n  }\n}\n</code></pre> <ol> <li><code>INGRESS_TRAFFIC_ALL</code> \u2014 API Gateway nie jest LB. Izolacja przez IAM: tylko <code>api-gateway-sa</code> z <code>roles/run.invoker</code> mo\u017ce wywo\u0142a\u0107 Cloud Run.</li> <li><code>var.image</code> \u2014 przy pierwszym Terraform apply: <code>latest</code>. Kolejne deploye u\u017cywaj\u0105 SHA tagu przez <code>gcloud run deploy</code> (obchodzi Terraform).</li> <li><code>min_instance_count = 0</code> \u2014 skaluje do zera. Cold start ~200\u2013500ms po idle. Produkcja z SLA: ustaw <code>min_instance_count = 1</code> (~$7/mies za always-on instancj\u0119).</li> </ol>"},{"location":"guide/04-backend/#sekwencja-bootstrapu-chicken-and-egg","title":"Sekwencja bootstrapu \u2014 chicken-and-egg","text":"<p>Problem: <code>terraform apply</code> dla Cloud Run wymaga obrazu w AR. AR musi istnie\u0107 zanim <code>docker push</code>.</p> <pre><code># Krok 1: tylko AR (bez Cloud Run)\nterraform apply \\\n  -target=google_project_service.apis \\\n  -target=google_artifact_registry_repository.backend_repo\n\n# Krok 2: zbuduj i wypchnij obraz\ngcloud auth configure-docker europe-central2-docker.pkg.dev\ndocker build -t europe-central2-docker.pkg.dev/PROJECT/backend/app:latest ./app\ndocker push europe-central2-docker.pkg.dev/PROJECT/backend/app:latest\n\n# Krok 3: pe\u0142ny apply (teraz Cloud Run znajdzie obraz)\nterraform apply\n</code></pre> <p>W <code>deploy.yml</code> (GitHub Actions) ta sekwencja jest zautomatyzowana jako osobne kroki z <code>if: github.event.inputs.layer == 'backend'</code>.</p>"},{"location":"guide/04-backend/#puapki","title":"Pu\u0142apki","text":"<p>Terraform nie wykrywa zmiany obrazu :latest</p> <p>Gdy aktualizujesz kod i pushasz nowy <code>:latest</code> do AR, Terraform widzi <code>image = \"...app:latest\"</code> \u2014 ta warto\u015b\u0107 si\u0119 nie zmieni\u0142a, wi\u0119c Terraform nie deployuje nowej wersji Cloud Run. Dlatego auto-deploy u\u017cywa <code>gcloud run deploy</code> z SHA tagiem bezpo\u015brednio, z pomini\u0119ciem Terraform state.</p> <p>Cold start przy min=0</p> <p>Pierwsze \u017c\u0105danie po ~15 minutach idle wymaga uruchomienia kontenera: ~200\u2013500ms dla tego obrazu. Je\u015bli Tw\u00f3j use case wymaga SLA &lt; 500ms \u2014 ustaw <code>min_instance_count = 1</code>.</p> <p>Cloud Run v2 vs v1</p> <p>U\u017cywamy <code>google_cloud_run_v2_service</code> (API v2). Starsza <code>google_cloud_run_service</code> (v1) ma inne pola (<code>template.0.metadata</code> zamiast <code>template</code>). Przy kopiowaniu przyk\u0142ad\u00f3w z internetu zawsze sprawd\u017a wersj\u0119 resource.</p>"},{"location":"guide/05-auth/","title":"Auth \u2014 Identity Platform + JWT","text":"<p>Uwierzytelnianie to jeden z trudniejszych kawa\u0142k\u00f3w tej architektury \u2014 wiele komponent\u00f3w musi by\u0107 zsynchronizowanych: Identity Platform, Firebase SDK, API Gateway, CORS, authorized_domains. Ten rozdzia\u0142 opisuje ca\u0142y przep\u0142yw.</p>"},{"location":"guide/05-auth/#przepyw-uwierzytelniania-end-to-end","title":"Przep\u0142yw uwierzytelniania end-to-end","text":"<pre><code>U\u017cytkownik klika \"Zaloguj przez Google\"\n    \u2502\n    \u25bc\nFirebase Auth SDK \u2192 signInWithPopup(auth, GoogleAuthProvider)\n    \u2502 OAuth 2.0 redirect\n    \u25bc\nGoogle OAuth consent screen\n    \u2502 user grants permission\n    \u25bc\nIdentity Platform wystawia JWT (ID Token)\n    Payload: {\n      sub: \"uid123\",         \u2190 unikalny user ID\n      email: \"user@gmail.com\",\n      name: \"Jan Kowalski\",\n      iss: \"https://securetoken.google.com/PROJECT_ID\",\n      aud: \"PROJECT_ID\",\n      exp: 1735000000        \u2190 wa\u017cny 1h\n    }\n    \u2502\n    \u25bc\nFrontend: Authorization: Bearer &lt;JWT&gt;\n    \u2502\n    \u25bc\nAPI Gateway weryfikuje JWT\n    \u2713 podpis (klucze publiczne securetoken.google.com)\n    \u2713 issuer == securetoken.google.com/PROJECT_ID\n    \u2713 audience == PROJECT_ID\n    \u2713 exp &gt; now\n    \u2502 (je\u015bli wszystko OK)\n    \u25bc\nCloud Run \u2014 decode_jwt(token) \u2192 claims\n    claims[\"sub\"] \u2192 uid (klucz dokumentu Firestore)\n    claims[\"email\"] \u2192 dane do zapisu\n</code></pre>"},{"location":"guide/05-auth/#terraform-warstwa-tfauth","title":"Terraform \u2014 warstwa <code>tf/auth/</code>","text":""},{"location":"guide/05-auth/#identity-platform-config","title":"Identity Platform config","text":"<pre><code>resource \"google_identity_platform_config\" \"default\" {\n  project = var.project_id\n\n  # Wszystkie domeny, z kt\u00f3rych Firebase Auth mo\u017ce by\u0107 u\u017cyty\n  authorized_domains = [\n    \"localhost\",                                       # dev lokalnie\n    \"storage.googleapis.com\",                          # legacy GCS URL\n    \"kamilos.xyz\",\n    \"app.kamilos.xyz\",                                 # prod\n    \"staging.kamilos.xyz\",                             # staging\n    \"gcp-prototype-1-20260224.firebaseapp.com\",        # (1)\n  ]\n}\n</code></pre> <ol> <li>Subdomena <code>firebaseapp.com</code> jest wymagana jako <code>authDomain</code> w Firebase SDK. Tworzy si\u0119 automatycznie po rejestracji projektu GCP w Firebase Console (<code>console.firebase.google.com</code>). Bez rejestracji \u2192 subdomena nie istnieje \u2192 <code>signInWithPopup</code> zwr\u00f3ci b\u0142\u0105d sieciowy.</li> </ol>"},{"location":"guide/05-auth/#google-sso-provider","title":"Google SSO provider","text":"<pre><code>resource \"google_identity_platform_default_supported_idp_config\" \"google\" {\n  idp_id        = \"google.com\"\n  client_id     = var.google_oauth_client_id\n  client_secret = var.google_oauth_client_secret\n  enabled       = true\n}\n</code></pre> <p><code>client_id</code> i <code>client_secret</code> tworzysz r\u0119cznie: GCP Console \u2192 APIs &amp; Services \u2192 Credentials \u2192 Create credentials \u2192 OAuth client ID \u2192 Web application. Nast\u0119pnie dodaj <code>Authorized redirect URI</code>: <pre><code>https://gcp-prototype-1-20260224.firebaseapp.com/__/auth/handler\n</code></pre></p>"},{"location":"guide/05-auth/#oauth-credentials-w-secret-manager","title":"OAuth credentials w Secret Manager","text":"<pre><code>resource \"google_secret_manager_secret\" \"oauth_client_id\" {\n  secret_id = \"identity-platform-oauth-client-id\"\n  replication { auto {} }\n}\n\nresource \"google_secret_manager_secret_version\" \"oauth_client_id\" {\n  secret      = google_secret_manager_secret.oauth_client_id.id\n  secret_data = var.google_oauth_client_id  # (1)\n}\n</code></pre> <ol> <li><code>secret_data</code> jest sensitive \u2014 Terraform nie wy\u015bwietli warto\u015bci w planie ani outputcie. Przechowujemy w Secret Manager dla audytowalno\u015bci dost\u0119pu (kto, kiedy, z jakiego SA czyta\u0142 secret).</li> </ol>"},{"location":"guide/05-auth/#frontend-firebase-sdk","title":"Frontend \u2014 Firebase SDK","text":"<pre><code>// frontend/app.js\n\nconst FIREBASE_CONFIG = {\n  // apiKey jest PUBLICZNY z za\u0142o\u017cenia architektury Firebase.\n  // Zabezpieczenie: authorized_domains w Identity Platform ogranicza,\n  // z jakich domen mo\u017cna u\u017cywa\u0107 tego klucza.\n  apiKey:     'AIzaSyDB9HH...',\n  authDomain: 'gcp-prototype-1-20260224.firebaseapp.com',\n  projectId:  'gcp-prototype-1-20260224',\n};\n\nconst app      = initializeApp(FIREBASE_CONFIG);\nconst auth     = getAuth(app);\nconst provider = new GoogleAuthProvider();\n\n// Logowanie \u2014 popup OAuth\nloginBtn.addEventListener('click', () =&gt; signInWithPopup(auth, provider));\n\n// Wylogowanie\nlogoutBtn.addEventListener('click', () =&gt; signOut(auth));\n\n// Reakcja na zmian\u0119 stanu auth (od\u015bwie\u017cenie strony, wyga\u015bni\u0119cie tokenu)\nonAuthStateChanged(auth, async (user) =&gt; {\n  if (user) {\n    const token = await auth.currentUser.getIdToken(); // (1)\n    // U\u017cyj tokenu do API calls\n    await fetch(`${API_URL}/api`, {\n      headers: { Authorization: `Bearer ${token}` }\n    });\n  }\n});\n</code></pre> <ol> <li><code>getIdToken()</code> automatycznie od\u015bwie\u017ca token je\u015bli zbli\u017ca si\u0119 expiry. Wywo\u0142uj przed ka\u017cdym API call \u2014 nie cachuj tokenu lokalnie (localStorage, sessionStorage).</li> </ol>"},{"location":"guide/05-auth/#puapki","title":"Pu\u0142apki","text":"<p>Identity Platform wymaga r\u0119cznej aktywacji w konsoli</p> <p><code>terraform apply</code> zwr\u00f3ci <code>Error 400: CONFIGURATION_NOT_FOUND</code> je\u015bli Identity Platform nie jest aktywowana r\u0119cznie. Kroki: 1. GCP Console \u2192 Identity Platform \u2192 Enable 2. Po aktywacji zas\u00f3b istnieje poza Terraform \u2014 trzeba zaimportowa\u0107: <pre><code>terraform import google_identity_platform_config.default \\\n  projects/PROJECT_ID/config\n</code></pre> W <code>deploy.yml</code> krok importu jest wbudowany z <code>|| true</code> (idempotentny).</p> <p>Firebase Console \u2014 projekt musi by\u0107 zarejestrowany</p> <p><code>authDomain: PROJECT_ID.firebaseapp.com</code> istnieje tylko gdy projekt GCP jest dodany do Firebase Console. Bez tego subdomena nie istnieje \u2192 <code>signInWithPopup</code> rzuci b\u0142\u0105d sieciowy bez czytelnego komunikatu.</p> <p>authorized_domains \u2014 ka\u017cda nowa domena</p> <p>Dodajesz nowe \u015brodowisko? Musisz doda\u0107 domen\u0119 do <code>authorized_domains</code>. Brak \u2192 Firebase Auth zwraca <code>auth/unauthorized-domain</code> bez szczeg\u00f3\u0142\u00f3w.</p> <p>apiKey w Firebase to nie sekret</p> <p>Firebase API Key (Web API Key) nie jest sekretem \u2014 jest publiczny w kodzie frontendowym. Nie wrzucaj go do Secret Manager. Zabezpieczenie: <code>authorized_domains</code> + IAM w Cloud Run. Atakuj\u0105cy z obcej domeny nie mo\u017ce u\u017cy\u0107 klucza do logowania.</p>"},{"location":"guide/06-api-gateway/","title":"API Gateway \u2014 walidacja i routing","text":"<p>API Gateway to jedyna brama do backendu. Ka\u017cde \u017c\u0105danie przechodzi przez ni\u0105 \u2014 bez wa\u017cnego JWT, Cloud Run nie dostanie requestu. To tzw. \"zero trust at the perimeter\".</p>"},{"location":"guide/06-api-gateway/#czym-jest-google-cloud-api-gateway","title":"Czym jest Google Cloud API Gateway","text":"<p>API Gateway to managed proxy opisany specyfikacj\u0105 OpenAPI (Swagger 2.0). Ka\u017cde \u017c\u0105danie:</p> <ol> <li>Sprawdza JWT (podpis, issuer, audience, expiry)</li> <li>Je\u015bli OK \u2014 przekazuje request do Cloud Run z OIDC tokenem SA</li> <li>Je\u015bli nie \u2014 zwraca 401 bez dotykania backendu</li> </ol> <pre><code>[Klient]\n    \u2502 HTTPS + Authorization: Bearer &lt;JWT u\u017cytkownika&gt;\n    \u25bc\n[API Gateway \u2014 europe-west1]\n    \u251c\u2500 walidacja JWT (Identity Platform issuer)\n    \u2502  \u2713 / \u2717\n    \u2502   \u2193 je\u015bli OK\n    \u251c\u2500 dodaje nag\u0142\u00f3wek Authorization: Bearer &lt;OIDC token api-gateway-sa&gt;\n    \u25bc\n[Cloud Run \u2014 europe-central2]\n    \u251c\u2500 sprawdza IAM: czy api-gateway-sa ma roles/run.invoker? \u2713\n    \u25bc\n[FastAPI: decode JWT, logika biznesowa]\n</code></pre>"},{"location":"guide/06-api-gateway/#openapi-spec-serce-konfiguracji","title":"OpenAPI spec \u2014 serce konfiguracji","text":"<pre><code># tf/api-gateway/openapi.yaml.tpl\n# Plik jest szablonem Terraform \u2014 ${variable} zast\u0119powane przy terraform apply\n\nswagger: \"2.0\"\ninfo:\n  title: \"gpc-api\"\n  version: \"1.0.0\"\n\nx-google-backend:\n  address: \"${cloud_run_url}\"          # (1)\n  jwt_audience: \"${cloud_run_url}\"     # (2)\n  path_translation: APPEND_PATH_TO_ADDRESS\n\nsecurityDefinitions:\n  firebase:\n    type: \"oauth2\"\n    flow: \"implicit\"\n    authorizationUrl: \"\"\n    x-google-issuer:   \"https://securetoken.google.com/${project_id}\"\n    x-google-jwks_uri: \"https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com\"\n    x-google-audiences: \"${project_id}\"   # (3)\n\npaths:\n  /health:\n    get:\n      operationId: \"health_check\"\n      security:\n        - firebase: []                  # (4) JWT wymagany\n      responses:\n        \"200\":\n          description: \"OK\"\n\n  /api:\n    options:\n      operationId: \"api_cors_preflight\"\n      security: []                      # (5) preflight BEZ JWT\n      responses:\n        \"204\":\n          description: \"CORS preflight\"\n    get:\n      operationId: \"api_list\"\n      security:\n        - firebase: []\n      responses:\n        \"200\":\n          description: \"OK\"\n    post:\n      operationId: \"api_create\"\n      security:\n        - firebase: []\n      responses:\n        \"200\":\n          description: \"OK\"\n</code></pre> <ol> <li><code>address</code> \u2014 URL Cloud Run (pobierany przez <code>data.google_cloud_run_v2_service.backend.uri</code>)</li> <li><code>jwt_audience</code> \u2014 audience dla OIDC tokenu do Cloud Run. Ten sam URL co adres backendu</li> <li><code>x-google-audiences</code> \u2014 audience dla JWT u\u017cytkownika (Firebase ID Token ma <code>aud = PROJECT_ID</code>)</li> <li><code>security: - firebase: []</code> \u2014 ta \u015bcie\u017cka wymaga JWT</li> <li><code>security: []</code> \u2014 CORS preflight (<code>OPTIONS</code>) nie ma nag\u0142\u00f3wka <code>Authorization</code>. Musi by\u0107 bez security, inaczej API Gateway zwr\u00f3ci 401 na preflight i przegl\u0105darka zablokuje ca\u0142y request</li> </ol>"},{"location":"guide/06-api-gateway/#terraform-warstwa-tfapi-gateway","title":"Terraform \u2014 warstwa <code>tf/api-gateway/</code>","text":""},{"location":"guide/06-api-gateway/#trzy-zasoby-na-kazdy-gateway-prod-i-staging","title":"Trzy zasoby na ka\u017cdy gateway (prod i staging)","text":"<pre><code># API \u2014 kontener logiczny\nresource \"google_api_gateway_api\" \"api\" {\n  provider     = google-beta          # (1)\n  api_id       = \"gpc-api\"\n  display_name = \"GPC API\"\n}\n\n# Config \u2014 konkretna wersja OpenAPI spec\nresource \"google_api_gateway_api_config\" \"config\" {\n  provider      = google-beta\n  api           = google_api_gateway_api.api.api_id\n  api_config_id = \"cfg-${substr(md5(local.openapi_spec), 0, 8)}\"  # (2)\n\n  openapi_documents {\n    document {\n      path     = \"spec.yaml\"\n      contents = base64encode(local.openapi_spec)  # (3)\n    }\n  }\n\n  gateway_config {\n    backend_config {\n      google_service_account = google_service_account.api_gw_sa.email\n    }\n  }\n\n  lifecycle {\n    create_before_destroy = true  # (4)\n  }\n}\n\n# Gateway \u2014 publiczny endpoint\nresource \"google_api_gateway_gateway\" \"gateway\" {\n  provider   = google-beta\n  api_config = google_api_gateway_api_config.config.id\n  gateway_id = \"gpc-gateway\"\n  region     = \"europe-west1\"    # (5)\n}\n</code></pre> <ol> <li><code>google-beta</code> \u2014 <code>google_api_gateway_*</code> zasoby s\u0105 w beta providerze. Wymaga osobnej konfiguracji <code>provider \"google-beta\"</code> w <code>provider.tf</code></li> <li><code>md5(local.openapi_spec)</code> \u2014 config ID zawiera hash specyfikacji. Gdy spec si\u0119 zmienia \u2192 nowy config ID \u2192 nowy zas\u00f3b \u2192 automatyczne rolowanie. Bez tego Terraform chcia\u0142by zmodyfikowa\u0107 immutable field i wywala\u0142 error</li> <li><code>base64encode</code> \u2014 API Gateway wymaga specyfikacji jako base64</li> <li><code>create_before_destroy</code> \u2014 stary config jest usuwany dopiero po stworzeniu nowego. Bez tego by\u0142by downtime podczas aktualizacji spec</li> <li><code>europe-west1</code> \u2014 API Gateway nie obs\u0142uguje <code>europe-central2</code>. Sta\u0142y region dla wszystkich gateway\u00f3w</li> </ol>"},{"location":"guide/06-api-gateway/#templatefile-dynamiczny-spec","title":"Templatefile \u2014 dynamiczny spec","text":"<pre><code>locals {\n  openapi_spec = templatefile(\"${path.module}/openapi.yaml.tpl\", {\n    cloud_run_url = data.google_cloud_run_v2_service.backend.uri\n    project_id    = var.project_id\n  })\n}\n</code></pre> <p><code>data.google_cloud_run_v2_service.backend.uri</code> pobiera URL Cloud Run z istniej\u0105cego stanu \u2014 dlatego warstwa <code>backend</code> musi by\u0107 wdro\u017cona przed <code>api-gateway</code>.</p>"},{"location":"guide/06-api-gateway/#iam-api-gateway-cloud-run","title":"IAM: API Gateway \u2192 Cloud Run","text":"<pre><code>resource \"google_service_account\" \"api_gw_sa\" {\n  account_id = \"api-gateway-sa\"\n}\n\n# SA mo\u017ce wywo\u0142ywa\u0107 Cloud Run\nresource \"google_cloud_run_v2_service_iam_member\" \"api_gw_invoker\" {\n  name   = data.google_cloud_run_v2_service.backend.name\n  role   = \"roles/run.invoker\"\n  member = \"serviceAccount:${google_service_account.api_gw_sa.email}\"\n}\n</code></pre>"},{"location":"guide/06-api-gateway/#puapki","title":"Pu\u0142apki","text":"<p>CORS preflight musi by\u0107 bez security</p> <p>Browser przed ka\u017cdym cross-origin requestem wysy\u0142a <code>OPTIONS</code> preflight bez nag\u0142\u00f3wk\u00f3w autoryzacji. Je\u015bli <code>OPTIONS /api</code> ma <code>security: - firebase: []</code>, API Gateway zwr\u00f3ci 401 \u2192 przegl\u0105darka zablokuje w\u0142a\u015bciwy request. Zawsze: <code>security: []</code> dla OPTIONS.</p> <p>api_config_id jest immutable</p> <p>Nie mo\u017cesz zmodyfikowa\u0107 istniej\u0105cego API Config \u2014 musisz stworzy\u0107 nowy. Dlatego ID zawiera hash spec: <code>cfg-${substr(md5(spec), 0, 8)}</code>. Terraform automatycznie tworzy nowy config gdy spec si\u0119 zmienia.</p> <p>Zale\u017cno\u015b\u0107: backend musi by\u0107 wdro\u017cony przed api-gateway</p> <p><code>data.google_cloud_run_v2_service.backend</code> odpytuje istniej\u0105cy Cloud Run. Je\u015bli backend nie istnieje \u2192 Terraform plan zwr\u00f3ci b\u0142\u0105d. Kolejno\u015b\u0107 deploy: backend \u2192 api-gateway.</p> <p>google-beta provider</p> <p>Dodaj osobn\u0105 konfiguracj\u0119 providera w <code>provider.tf</code>: <pre><code>provider \"google-beta\" {\n  project = var.project_id\n  region  = var.region\n}\n</code></pre> Terraform wymaga explicytnej konfiguracji <code>google-beta</code> \u2014 nie dziedziczy automatycznie z <code>google</code>.</p>"},{"location":"guide/07-database/","title":"Baza danych \u2014 Firestore","text":"<p>Firestore to dokument NoSQL \u2014 bez schematu, bez migracji, bez konfiguracji sieci. Jeden zas\u00f3b Terraform, zerowy koszt baseline.</p>"},{"location":"guide/07-database/#dlaczego-firestore-nie-cloud-sql","title":"Dlaczego Firestore, nie Cloud SQL","text":"<p>Pe\u0142ne por\u00f3wnanie w ADR-002. Skr\u00f3t:</p> Kryterium Cloud SQL Firestore Koszt przy 0 req ~$7/mies (instancja dzia\u0142a zawsze) $0 Koszt przy ma\u0142ym ruchu ~$7/mies $0 Zasoby Terraform ~5 (instance, db, user, VPC peering, proxy) 1 (<code>google_firestore_database</code>) Migracje schematu Wymagane (Alembic/Flyway) Brak schematu Po\u0142\u0105czenie z Cloud Run Cloud SQL Auth Proxy lub Private IP Bezpo\u015brednio przez HTTP API Backup Point-in-time recovery Geo-replikacja managed <p>Wybrali\u015bmy Firestore bo model danych aplikacji (lista logowa\u0144 per user) jest naturalnie dokumentowy, a koszt jest kluczowy dla prototypu.</p>"},{"location":"guide/07-database/#terraform-warstwa-tfdatabase","title":"Terraform \u2014 warstwa <code>tf/database/</code>","text":"<pre><code># tf/database/main.tf\n\n# W\u0142\u0105cz Firestore API\nresource \"google_project_service\" \"apis\" {\n  service            = \"firestore.googleapis.com\"\n  disable_on_destroy = false\n}\n\n# Baza danych Firestore (jedna per projekt \u2014 \"default\")\nresource \"google_firestore_database\" \"db\" {\n  project     = var.project_id\n  name        = \"(default)\"            # (1)\n  location_id = var.region             # europe-central2\n  type        = \"FIRESTORE_NATIVE\"     # (2)\n\n  depends_on = [google_project_service.apis]\n}\n\n# IAM \u2014 Cloud Run SA mo\u017ce czyta\u0107/pisa\u0107\nresource \"google_project_iam_member\" \"run_sa_firestore\" {\n  project = var.project_id\n  role    = \"roles/datastore.user\"     # (3)\n  member  = \"serviceAccount:cloud-run-backend-sa@${var.project_id}.iam.gserviceaccount.com\"\n}\n</code></pre> <ol> <li><code>name = \"(default)\"</code> \u2014 Firestore obs\u0142uguje jedn\u0105 baz\u0119 <code>(default)</code> per projekt na Free tier. Kolejne bazy wymagaj\u0105 Blaze plan.</li> <li><code>FIRESTORE_NATIVE</code> vs <code>DATASTORE_MODE</code> \u2014 Native obs\u0142uguje realtime listeners, richer query model, better SDK. Datastore Mode to tryb kompatybilno\u015bci z Cloud Datastore. Zawsze wybieraj Native dla nowych projekt\u00f3w.</li> <li><code>roles/datastore.user</code> \u2014 mo\u017ce czyta\u0107, pisa\u0107, usuwa\u0107 dokumenty. Nie mo\u017ce zarz\u0105dza\u0107 baz\u0105 (tworzy\u0107 indeks\u00f3w programatycznie, usuwa\u0107 bazy). Zasada least privilege.</li> </ol>"},{"location":"guide/07-database/#model-danych","title":"Model danych","text":"<p>Kolekcje Firestore nie wymagaj\u0105 wcze\u015bniejszego tworzenia \u2014 powstaj\u0105 przy pierwszym zapisie.</p> <pre><code>Firestore \"(default)\"\n\u2502\n\u251c\u2500 logins/                              \u2190 kolekcja (prod)\n\u2502  \u2514\u2500 {uid}/                            \u2190 dokument = user ID (z JWT sub)\n\u2502     \u2514\u2500 events/                        \u2190 subkolekcja\n\u2502        \u251c\u2500 {auto_id}/                  \u2190 dokument = jedno logowanie\n\u2502        \u2502  \u251c\u2500 timestamp: Timestamp\n\u2502        \u2502  \u251c\u2500 email: \"user@gmail.com\"\n\u2502        \u2502  \u2514\u2500 name: \"Jan Kowalski\"\n\u2502        \u2514\u2500 ...\n\u2502\n\u2514\u2500 staging_logins/                      \u2190 kolekcja (staging)\n   \u2514\u2500 {uid}/\n      \u2514\u2500 events/\n         \u2514\u2500 ...\n</code></pre> <p>Izolacja prod/staging przez prefix kolekcji (<code>staging_</code>) \u2014 ten sam projekt GCP, ta sama baza Firestore, ale oddzielne dane.</p>"},{"location":"guide/07-database/#klient-python-google-cloud-firestore","title":"Klient Python \u2014 <code>google-cloud-firestore</code>","text":"<pre><code>from google.cloud import firestore\n\n# Client u\u017cywa Application Default Credentials\n# W Cloud Run: automatycznie u\u017cywa SA cloud-run-backend-sa\ndb = firestore.Client()\n\n# Zapis\ndb.collection(\"logins\") \\\n  .document(uid) \\\n  .collection(\"events\") \\\n  .add({\n      \"timestamp\": datetime.now(timezone.utc),\n      \"email\": email,\n  })\n\n# Odczyt \u2014 ostatnie 5, posortowane malej\u0105co\nevents = (\n    db.collection(\"logins\")\n      .document(uid)\n      .collection(\"events\")\n      .order_by(\"timestamp\", direction=firestore.Query.DESCENDING)\n      .limit(5)\n      .stream()\n)\n</code></pre> <p><code>firestore.Client()</code> bez argument\u00f3w u\u017cywa ADC. W Cloud Run \u2014 SA <code>cloud-run-backend-sa</code> z rol\u0105 <code>roles/datastore.user</code>. Lokalnie \u2014 Twoje konto (przez <code>gcloud auth application-default login</code>).</p>"},{"location":"guide/07-database/#free-tier-firestore","title":"Free tier Firestore","text":"Metryka Free tier limit/dzie\u0144 Odczyty dokument\u00f3w 50,000 Zapisy dokument\u00f3w 20,000 Usuni\u0119cia dokument\u00f3w 20,000 Storage 1 GB \u0142\u0105cznie Egress 10 GB/mies <p>Dla prototypu z kilkoma u\u017cytkownikami \u2014 Free tier wystarczy na wiele miesi\u0119cy.</p>"},{"location":"guide/07-database/#puapki","title":"Pu\u0142apki","text":"<p>Firestore database jest immutable po stworzeniu</p> <p>Po <code>terraform apply</code> nie mo\u017cesz zmieni\u0107 <code>location_id</code> ani <code>type</code>. Zmiana = <code>destroy + create</code> = utrata wszystkich danych. Wybierz region raz i trzymaj si\u0119 go.</p> <p>roles/datastore.admin nie dzia\u0142a na poziomie projektu</p> <p>Google nie obs\u0142uguje <code>roles/datastore.admin</code> jako project-level IAM binding (zwraca Error 400). Dost\u0119pna alternatywa: <code>roles/datastore.owner</code> \u2014 szersza rola (mo\u017ce zarz\u0105dza\u0107 sam\u0105 baz\u0105). Dla uprawnie\u0144 CI/CD SA (<code>gh-infra-worker</code>) u\u017cywamy <code>roles/datastore.owner</code>; dla Cloud Run runtime SA (<code>cloud-run-backend-sa</code>) \u2014 <code>roles/datastore.user</code>.</p> <p>Indeksy kompozytowe</p> <p><code>order_by(\"timestamp\").limit(5)</code> nie wymaga dodatkowego indeksu \u2014 Firestore ma automatyczne indeksy dla pojedynczych p\u00f3l. Z\u0142o\u017cone zapytania (order_by po wielu polach, where + order_by po r\u00f3\u017cnych polach) wymagaj\u0105 manualnego tworzenia indeks\u00f3w w konsoli lub przez <code>gcloud firestore indexes create</code>.</p>"},{"location":"guide/08-frontend/","title":"Frontend \u2014 GCS + Cloudflare CDN","text":"<p>Hosting SPA (Single Page Application) za $0/mies. GCS bucket jako origin, Cloudflare jako CDN, SSL i DDoS protection \u2014 bez Google Load Balancera.</p>"},{"location":"guide/08-frontend/#ewolucja-architektury-frontendu","title":"Ewolucja architektury frontendu","text":"<pre><code>Etap 1 (ADR-003): GCS bucket bezpo\u015brednio\n  URL: https://storage.googleapis.com/frontend-bucket/index.html\n  \u2713 $0 koszt\n  \u2717 brak custom domeny, brak HTTPS na w\u0142asnej domenie\n\nEtap 2 (ADR-005): Cloudflare CDN jako proxy przed GCS\n  URL: https://app.kamilos.xyz\n  \u2713 custom domena z HTTPS\n  \u2713 CDN (PoP Warszawa/Frankfurt)\n  \u2713 DDoS protection L3/L4/L7\n  \u2713 WAF (managed rules)\n  \u2713 $0/mies (Cloudflare Free tier)\n  \u2717 Bucket musi si\u0119 nazywa\u0107 dok\u0142adnie jak domena (CNAME trick)\n</code></pre>"},{"location":"guide/08-frontend/#cloudflare-cname-trick-dlaczego-bucket-musi-miec-nazwe-domeny","title":"Cloudflare CNAME trick \u2014 dlaczego bucket musi mie\u0107 nazw\u0119 domeny","text":"<p>GCS obs\u0142uguje custom domeny przez CNAME do <code>c.storage.googleapis.com</code>. Gdy request przychodzi na <code>app.kamilos.xyz</code>, GCS szuka bucketa o nazwie <code>app.kamilos.xyz</code>.</p> <pre><code>Browser \u2192 app.kamilos.xyz\n    \u2502 DNS\n    \u25bc\nCloudflare Edge (proxy ON \u2014 orange cloud)\n    \u2502 origin request to storage.googleapis.com\n    \u2502 Host: app.kamilos.xyz\n    \u25bc\nGCS \u2192 szuka bucketa \"app.kamilos.xyz\"\n    \u2192 serwuje pliki z tego bucketa\n</code></pre> <p>Bez Cloudflare: CNAME <code>app \u2192 c.storage.googleapis.com</code> \u2014 HTTP tylko (GCS nie terminuje SSL na custom domenach). Z Cloudflare proxy: SSL terminowany na edge Cloudflare, GCS dostaje HTTP od Cloudflare.</p>"},{"location":"guide/08-frontend/#terraform-warstwa-tffrontend","title":"Terraform \u2014 warstwa <code>tf/frontend/</code>","text":"<pre><code># tf/frontend/main.tf\n\nresource \"google_storage_bucket\" \"frontend\" {\n  name                        = \"app.kamilos.xyz\"       # (1)\n  project                     = var.project_id\n  location                    = \"EU\"                     # (2)\n  uniform_bucket_level_access = true\n  public_access_prevention    = \"unspecified\"            # (3)\n  force_destroy               = true\n\n  website {\n    main_page_suffix = \"index.html\"\n    not_found_page   = \"index.html\"  # (4)\n  }\n}\n\nresource \"google_storage_bucket_iam_member\" \"public_read\" {\n  bucket = google_storage_bucket.frontend.name\n  role   = \"roles/storage.objectViewer\"\n  member = \"allUsers\"                                    # (5)\n}\n</code></pre> <ol> <li><code>name = \"app.kamilos.xyz\"</code> \u2014 nazwa bucketa = domena. Wymagane przez CNAME trick</li> <li><code>location = \"EU\"</code> \u2014 multi-region EU, ta\u0144szy ni\u017c single-region <code>europe-central2</code>, szybszy dla u\u017cytkownik\u00f3w w Europie</li> <li><code>public_access_prevention = \"unspecified\"</code> \u2014 musi by\u0107 <code>unspecified</code> (nie <code>enforced</code>) \u017ceby <code>allUsers objectViewer</code> zadzia\u0142a\u0142o. Dla bucket\u00f3w backendowych (stan TF): <code>enforced</code></li> <li><code>not_found_page = \"index.html\"</code> \u2014 SPA routing. <code>GET /app/profile</code> \u2192 plik nie istnieje \u2192 GCS zwraca <code>index.html</code> z HTTP 404. JS router przejmuje \u2192 wy\u015bwietla w\u0142a\u015bciwy widok. Uwaga: HTTP 404 zamiast 200 dla deep links \u2014 Cloudflare mo\u017ce cachowa\u0107 404. Rozwi\u0105zanie: Page Rule lub Transform Rule w Cloudflare (redirect 404 \u2192 200)</li> <li><code>allUsers objectViewer</code> \u2014 publiczny dost\u0119p do czytania obiekt\u00f3w (pobieranie plik\u00f3w). Nie daje uprawnie\u0144 do zarz\u0105dzania bucketem</li> </ol>"},{"location":"guide/08-frontend/#konfiguracja-cloudflare-dns","title":"Konfiguracja Cloudflare DNS","text":"<p>W panelu Cloudflare dla domeny <code>kamilos.xyz</code>:</p> <pre><code>Type   Name      Content                        Proxy status\nCNAME  app       c.storage.googleapis.com       Proxied (orange cloud) \u2713\nCNAME  staging   c.storage.googleapis.com       Proxied (orange cloud) \u2713\n</code></pre> <p>Proxy ON (orange) \u2014 obowi\u0105zkowo dla HTTPS</p> <p>Przy proxy OFF (grey cloud): CNAME wskazuje bezpo\u015brednio na GCS, kt\u00f3ry nie ma certyfikatu dla <code>app.kamilos.xyz</code> \u2192 przegl\u0105darka pokazuje \"not secure\". Z proxy ON: Cloudflare terminuje SSL, GCS dostaje HTTP od Cloudflare edge.</p>"},{"location":"guide/08-frontend/#deploy-plikow","title":"Deploy plik\u00f3w","text":""},{"location":"guide/08-frontend/#reczny-deploy","title":"R\u0119czny deploy","text":"<pre><code># Prod\ngcloud storage cp -r ./dist/* gs://app.kamilos.xyz/\n\n# Ze strategi\u0105 cache-control\ngcloud storage cp frontend/index.html gs://app.kamilos.xyz/ \\\n  --cache-control=\"no-cache, no-store, must-revalidate\"\ngcloud storage cp frontend/app.js gs://app.kamilos.xyz/ \\\n  --cache-control=\"public, max-age=3600\"\n</code></pre>"},{"location":"guide/08-frontend/#auto-deploy-przez-github-actions","title":"Auto-deploy przez GitHub Actions","text":"<pre><code># deploy-frontend.yml \u2014 fragment (prod)\n- name: Deploy to prod (master)\n  if: github.ref_name == 'master'\n  run: |\n    gcloud storage cp frontend/app.js \\\n      gs://app.kamilos.xyz/app.js \\\n      --cache-control=\"public, max-age=3600\"\n    gcloud storage cp frontend/index.html \\\n      gs://app.kamilos.xyz/index.html \\\n      --cache-control=\"no-cache, no-store, must-revalidate\"\n</code></pre> <p><code>index.html</code> z <code>no-cache</code> \u2014 przegl\u0105darka zawsze pobiera \u015bwie\u017c\u0105 wersj\u0119, kt\u00f3ra zawiera <code>&lt;script src=\"app.js?v=XXX\"&gt;</code>. JS i CSS z <code>max-age=3600</code> \u2014 1h cache na edge i w przegl\u0105darce.</p>"},{"location":"guide/08-frontend/#aplikacja-spa-frontendappjs","title":"Aplikacja SPA \u2014 <code>frontend/app.js</code>","text":"<pre><code>// Konfiguracja Firebase (apiKey jest publiczny)\nconst FIREBASE_CONFIG = {\n  apiKey:     'AIzaSyDB9HH...',\n  authDomain: 'gcp-prototype-1-20260224.firebaseapp.com',\n  projectId:  'gcp-prototype-1-20260224',\n};\n\n// URL API Gateway \u2014 hardkodowany dla prod\n// Dla staging: nadpisywany przez `sed` w deploy-frontend.yml\nconst API_URL = 'https://gpc-gateway-31x6ik0l.ew.gateway.dev';\n\n// Po zalogowaniu: zapisz logowanie + pobierz histori\u0119\nasync function recordAndShowLogins() {\n  const token = await auth.currentUser.getIdToken();\n  const headers = { Authorization: `Bearer ${token}` };\n\n  await fetch(`${API_URL}/api`, { method: 'POST', headers });\n  const res = await fetch(`${API_URL}/api`, { headers });\n  const data = await res.json();\n  renderLogins(data.last_logins ?? []);\n}\n</code></pre>"},{"location":"guide/08-frontend/#puapki","title":"Pu\u0142apki","text":"<p>Cloudflare cache \u2014 po deployu wymagany hard refresh</p> <p><code>app.js</code> jest cachowany przez 1h na edge Cloudflare. Po deployowaniu nowej wersji: <code>Cmd+Shift+R</code> (hard refresh) lub poczekaj 1h. Dla automatycznego inwalidowania: Cloudflare Cache Purge przez API lub Page Rule z <code>Cache-Control: no-store</code> dla <code>index.html</code> (kt\u00f3ry \u0142aduje <code>app.js</code> z nowym hash/version).</p> <p>GCS nie serwuje HTTPS na custom domenach bezpo\u015brednio</p> <p>GCS ma certyfikat dla <code>*.storage.googleapis.com</code>, nie dla <code>app.kamilos.xyz</code>. Cloudflare proxy jest wymagany dla HTTPS na custom domenie. Alternatywa bez Cloudflare: Google Load Balancer z SSL certificate resource (~$23/mies).</p> <p>SPA routing a HTTP 404</p> <p><code>not_found_page = \"index.html\"</code> zwraca status 404 z tre\u015bci\u0105 <code>index.html</code>. Wi\u0119kszo\u015b\u0107 SPA router\u00f3w dzia\u0142a z tym poprawnie. Je\u015bli Cloudflare Page Cache cachuje 404 b\u0142\u0119dnie \u2014 dodaj Cloudflare Page Rule: <code>app.kamilos.xyz/*</code> \u2192 Cache Level: Bypass.</p>"},{"location":"guide/09-cicd/","title":"CI/CD \u2014 GitHub Actions","text":"<p>Trzy workflowy, zero kluczy serwisowych. Ka\u017cdy push do odpowiedniego brancha i \u015bcie\u017cki wyzwala automatyczny deploy.</p>"},{"location":"guide/09-cicd/#mapa-workflowow","title":"Mapa workflow\u00f3w","text":"<pre><code>.github/workflows/\n\u251c\u2500\u2500 deploy.yml           \u2190 r\u0119czny, wszystkie warstwy TF (plan/apply)\n\u251c\u2500\u2500 deploy-backend.yml   \u2190 auto, push do app/ \u2192 Cloud Run\n\u251c\u2500\u2500 deploy-frontend.yml  \u2190 auto, push do frontend/ \u2192 GCS\n\u2514\u2500\u2500 docs.yml             \u2190 auto, push do docs/guide/ \u2192 GitHub Pages\n</code></pre> Workflow Wyzwalacz Co robi <code>deploy.yml</code> <code>workflow_dispatch</code> (r\u0119czny) terraform plan/apply dla wybranej warstwy <code>deploy-backend.yml</code> push <code>app/**</code> na master/develop docker build+push SHA \u2192 gcloud run deploy <code>deploy-frontend.yml</code> push <code>frontend/**</code> na master/develop gcloud storage cp \u2192 GCS bucket <code>docs.yml</code> push <code>docs/guide/**</code> lub <code>mkdocs.yml</code> mkdocs gh-deploy \u2192 GitHub Pages"},{"location":"guide/09-cicd/#uwierzytelnianie-bez-kluczy-wif","title":"Uwierzytelnianie bez kluczy \u2014 WIF","text":"<p>Ka\u017cdy workflow zaczyna si\u0119 tak samo:</p> <pre><code>permissions:\n  id-token: write   # (1) WYMAGANE \u2014 bez tego GitHub nie udost\u0119pni OIDC token\n  contents: read\n\nsteps:\n  - uses: actions/checkout@v4\n\n  - name: Authenticate to Google Cloud\n    uses: google-github-actions/auth@v2\n    with:\n      workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}\n      service_account: ${{ secrets.GCP_SA_EMAIL }}\n\n  - name: Set up Cloud SDK\n    uses: google-github-actions/setup-gcloud@v2\n</code></pre> <ol> <li><code>id-token: write</code> \u2014 kluczowa linia na poziomie <code>permissions</code>. Bez niej GitHub odrzuci pr\u00f3b\u0119 pobrania OIDC token z komunikatem \"Credentials could not be loaded\".</li> </ol> <p>Po tych krokach wszystkie narz\u0119dzia (<code>gcloud</code>, <code>terraform</code>, Docker) maj\u0105 dost\u0119p do GCP przez ADC.</p>"},{"location":"guide/09-cicd/#deployyml-reczny-deploy-terraform","title":"deploy.yml \u2014 r\u0119czny deploy Terraform","text":"<pre><code>on:\n  workflow_dispatch:\n    inputs:\n      action:\n        type: choice\n        options: [plan, apply]\n        default: plan\n      layer:\n        type: choice\n        options: [infra, backend, auth, api-gateway, database, frontend, monitoring]\n\njobs:\n  terraform:\n    env:\n      TF_VAR_project_id:                  ${{ secrets.GCP_PROJECT_ID }}\n      TF_VAR_region:                      europe-central2\n      TF_VAR_google_oauth_client_id:      ${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}\n      TF_VAR_google_oauth_client_secret:  ${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET }}\n      TF_VAR_alert_email:                 ${{ secrets.ALERT_EMAIL }}\n\n    steps:\n      # ... auth steps ...\n\n      - name: Terraform Init\n        working-directory: ./tf/${{ github.event.inputs.layer }}\n        run: |\n          terraform init \\\n            -backend-config=\"bucket=tf-state-${{ secrets.GCP_PROJECT_ID }}\" \\\n            -backend-config=\"prefix=terraform/${{ github.event.inputs.layer }}/state\"\n\n      - name: Terraform Plan\n        run: terraform plan -var=\"project_id=...\" -out=tfplan\n\n      # Specjalne kroki dla backend apply: AR \u2192 Docker \u2192 full apply\n      - name: Bootstrap Artifact Registry\n        if: inputs.action == 'apply' &amp;&amp; inputs.layer == 'backend'\n        run: terraform apply -auto-approve -target=google_artifact_registry_repository.backend_repo ...\n\n      - name: Build and push Docker image\n        if: inputs.action == 'apply' &amp;&amp; inputs.layer == 'backend'\n        run: |\n          docker build -t \"${IMAGE}:${{ github.sha }}\" ./app\n          docker push \"${IMAGE}:${{ github.sha }}\"\n\n      # Auth: import Identity Platform config przed apply\n      - name: Import Identity Platform config\n        if: inputs.action == 'apply' &amp;&amp; inputs.layer == 'auth'\n        run: |\n          terraform import ... google_identity_platform_config.default \\\n            projects/${{ secrets.GCP_PROJECT_ID }}/config || true\n\n      - name: Terraform Apply\n        if: inputs.action == 'apply'\n        run: |\n          if [ \"${{ inputs.layer }}\" = \"backend\" ] || [ \"${{ inputs.layer }}\" = \"auth\" ]; then\n            terraform apply -auto-approve -var=\"project_id=...\"  # (1)\n          else\n            terraform apply -auto-approve tfplan                  # (2)\n          fi\n</code></pre> <ol> <li>Backend i auth: <code>apply</code> bez saved plan \u2014 stan zmieni\u0142 si\u0119 przez <code>-target apply</code> (backend) lub <code>import</code> (auth), wi\u0119c saved tfplan by\u0142by nieaktualny</li> <li>Pozosta\u0142e warstwy: <code>apply tfplan</code> \u2014 deterministyczne, dok\u0142adnie to co zosta\u0142o zaplanowane</li> </ol>"},{"location":"guide/09-cicd/#deploy-backendyml-auto-deploy-cloud-run","title":"deploy-backend.yml \u2014 auto-deploy Cloud Run","text":"<pre><code>on:\n  push:\n    branches: [master, develop]\n    paths:\n      - 'app/**'           # (1) tylko gdy zmieni\u0142 si\u0119 kod aplikacji\n\njobs:\n  deploy:\n    env:\n      IMAGE:        europe-central2-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/backend/app\n      SERVICE_NAME: ${{ github.ref_name == 'develop' &amp;&amp; 'backend-api-staging' || 'backend-api' }}  # (2)\n\n    steps:\n      # ... auth ...\n\n      - name: Build and push Docker image\n        run: |\n          docker build \\\n            -t \"${{ env.IMAGE }}:latest\" \\\n            -t \"${{ env.IMAGE }}:${{ github.sha }}\" \\  # (3)\n            ./app\n          docker push \"${{ env.IMAGE }}:${{ github.sha }}\"\n          docker push \"${{ env.IMAGE }}:latest\"\n\n      - name: Deploy to Cloud Run\n        run: |\n          gcloud run deploy ${{ env.SERVICE_NAME }} \\\n            --image=\"${{ env.IMAGE }}:${{ github.sha }}\" \\  # (4)\n            --region=europe-central2 \\\n            --project=${{ secrets.GCP_PROJECT_ID }} \\\n            --quiet\n</code></pre> <ol> <li><code>paths: ['app/**']</code> \u2014 workflow nie uruchamia si\u0119 przy zmianie docs, TF, frontend. Tylko kod aplikacji.</li> <li><code>github.ref_name == 'develop' &amp;&amp; 'backend-api-staging' || 'backend-api'</code> \u2014 ternary w bash expression. <code>develop</code> \u2192 staging, wszystko inne \u2192 prod</li> <li>SHA tag \u2014 ka\u017cdy commit dostaje unikalny tag (40-znakowy git SHA). Pozwala zidentyfikowa\u0107 dok\u0142adn\u0105 wersj\u0119 obrazu w production</li> <li><code>--image=...:SHA</code> zamiast <code>:latest</code> \u2014 wymusza now\u0105 rewizj\u0119 Cloud Run przy ka\u017cdym deploy. Terraform z <code>image = \"...:latest\"</code> nie wykry\u0142by zmiany; <code>gcloud run deploy</code> zawsze deployuje podany obraz</li> </ol>"},{"location":"guide/09-cicd/#deploy-frontendyml-auto-deploy-gcs","title":"deploy-frontend.yml \u2014 auto-deploy GCS","text":"<pre><code>on:\n  push:\n    branches: [master, develop]\n    paths:\n      - 'frontend/**'\n\njobs:\n  deploy:\n    steps:\n      # ... auth ...\n\n      - name: Deploy to prod (master)\n        if: github.ref_name == 'master'\n        run: |\n          gcloud storage cp frontend/index.html gs://app.kamilos.xyz/ \\\n            --cache-control=\"no-cache, no-store, must-revalidate\"\n          gcloud storage cp frontend/app.js gs://app.kamilos.xyz/ \\\n            --cache-control=\"public, max-age=3600\"\n\n      - name: Deploy to staging (develop)\n        if: github.ref_name == 'develop'\n        run: |\n          # Pobierz URL staging API Gateway dynamicznie\n          STAGING_HOSTNAME=$(gcloud api-gateway gateways describe gpc-gateway-staging \\\n            --location=europe-west1 \\\n            --project=${{ secrets.GCP_PROJECT_ID }} \\\n            --format=\"value(defaultHostname)\")\n\n          # Podmie\u0144 API_URL w app.js na URL staging (bez modyfikacji repo)\n          sed \"s|const API_URL = '.*'|const API_URL = 'https://${STAGING_HOSTNAME}'|\" \\\n            frontend/app.js &gt; /tmp/app.staging.js\n\n          gcloud storage cp /tmp/app.staging.js gs://staging.kamilos.xyz/app.js \\\n            --cache-control=\"public, max-age=3600\"\n</code></pre> <p><code>sed</code> nadpisuje URL API w locie, bez commitowania zmiany do repo. Staging dostaje sw\u00f3j URL API Gateway, prod \u2014 hardkodowany URL z pliku.</p>"},{"location":"guide/09-cicd/#github-secrets","title":"GitHub Secrets","text":"Secret Ustawiany przez Warto\u015b\u0107 <code>GCP_PROJECT_ID</code> <code>bob_budowniczy.sh</code> <code>gcp-prototype-1-20260224</code> <code>GCP_WIF_PROVIDER</code> <code>bob_budowniczy.sh</code> <code>projects/NUMBER/locations/global/workloadIdentityPools/...</code> <code>GCP_SA_EMAIL</code> <code>bob_budowniczy.sh</code> <code>gh-infra-worker@PROJECT.iam.gserviceaccount.com</code> <code>GOOGLE_OAUTH_CLIENT_ID</code> r\u0119cznie OAuth 2.0 client ID z GCP Console <code>GOOGLE_OAUTH_CLIENT_SECRET</code> r\u0119cznie OAuth 2.0 client secret <code>ALERT_EMAIL</code> r\u0119cznie email na alerty monitoringu <code>GCP_BILLING_ACCOUNT_ID</code> r\u0119cznie (opcjonalny) ID billing account (budget alert)"},{"location":"guide/09-cicd/#puapki","title":"Pu\u0142apki","text":"<p>Terraform apply bez aktualnego planu</p> <p>Deploy backend i auth u\u017cywa <code>apply</code> bez saved tfplan \u2014 je\u015bli co\u015b zmieni\u0142o si\u0119 w stanie mi\u0119dzy <code>plan</code> a <code>apply</code>, Terraform mo\u017ce zaskoczy\u0107. W praktyce: accept it dla tych warstw, bo <code>-target</code> apply i <code>import</code> zawsze zmieniaj\u0105 stan.</p> <p>SHA tag: docker push obu tag\u00f3w</p> <p>Push <code>\":SHA\"</code> i <code>\":latest\"</code>. Gdyby\u015b pushowa\u0142 tylko SHA, nast\u0119pny <code>terraform plan</code> dla backend widzi <code>image=...:latest</code> i twierdzi \u017ce nie ma zmian (bo obraz latest to stary obraz). Push <code>\":latest\"</code> zapewnia \u017ce manual deploy przez <code>deploy.yml</code> te\u017c dostanie nowy obraz.</p> <p>Monitoring deploy\u00f3w</p> <pre><code># Lista ostatnich run dla konkretnego workflow\ngh run list --workflow=deploy-backend.yml --limit=5\n\n# Podgl\u0105d log\u00f3w konkretnego run\ngh run view RUN_ID --log\n\n# Watch w czasie rzeczywistym\ngh run watch RUN_ID\n</code></pre>"},{"location":"guide/10-staging/","title":"Staging \u2014 multi-env w jednym projekcie","text":"<p>Staging to oddzielne \u015brodowisko testowe \u2014 takie same zasoby co prod, ale z sufiksem <code>-staging</code>. Jeden projekt GCP, jeden Firestore, r\u00f3\u017cne dane.</p>"},{"location":"guide/10-staging/#dlaczego-jeden-projekt-nie-dwa","title":"Dlaczego jeden projekt, nie dwa?","text":"<p>Szczeg\u00f3\u0142y w ADR-007. Skr\u00f3t:</p> Kryterium Dwa projekty Jeden projekt (nasze) Izolacja danych Pe\u0142na Przez prefix kolekcji Firestore Koszt 2\u00d7 VPC Connector (~$14/mies) 1\u00d7 VPC Connector (~$7/mies) IAM/billing Oddzielny dla ka\u017cdego env Wsp\u00f3lny Z\u0142o\u017cono\u015b\u0107 TF Oddzielne state bucket, providery Jeden state bucket, prefiksy Wystarczaj\u0105ce dla Compliance-heavy produkcji Prototyp, wczesna faza produktu"},{"location":"guide/10-staging/#wzorzec-suffix-staging","title":"Wzorzec suffix <code>-staging</code>","text":"<p>Ka\u017cdy zas\u00f3b staging to kopia prod z sufiksem:</p> Zas\u00f3b Prod Staging Cloud Run <code>backend-api</code> <code>backend-api-staging</code> API Gateway <code>gpc-gateway</code> <code>gpc-gateway-staging</code> API Gateway SA <code>api-gateway-sa</code> <code>api-gateway-staging-sa</code> GCS bucket <code>app.kamilos.xyz</code> <code>staging.kamilos.xyz</code> Firestore kolekcja <code>logins/{uid}/events</code> <code>staging_logins/{uid}/events</code> URL <code>https://app.kamilos.xyz</code> <code>https://staging.kamilos.xyz</code>"},{"location":"guide/10-staging/#izolacja-przez-zmienna-srodowiskowa","title":"Izolacja przez zmienn\u0105 \u015brodowiskow\u0105","text":"<pre><code># tf/backend/main.tf \u2014 Cloud Run staging\nresource \"google_cloud_run_v2_service\" \"backend_staging\" {\n  name = \"backend-api-staging\"\n  labels = { env = \"staging\" }\n\n  template {\n    containers {\n      image = var.image\n      env {\n        name  = \"ENV\"\n        value = \"staging\"   # (1)\n      }\n    }\n  }\n}\n</code></pre> <ol> <li><code>ENV=staging</code> ustawiane przez Terraform przy tworzeniu Cloud Run. Ten sam obraz Docker \u2014 zachowanie zmienia si\u0119 przez env var.</li> </ol> <pre><code># app/main.py\nENV = os.getenv(\"ENV\", \"prod\")\nCOLLECTION_PREFIX = \"staging_\" if ENV == \"staging\" else \"\"\n\n# Prod:    kolekcja \"logins/{uid}/events\"\n# Staging: kolekcja \"staging_logins/{uid}/events\"\n</code></pre>"},{"location":"guide/10-staging/#mapowanie-branch-srodowisko","title":"Mapowanie branch \u2192 \u015brodowisko","text":"<pre><code>master  \u2192 prod\ndevelop \u2192 staging\n\npush do app/ na master  \u2192 deploy do backend-api\npush do app/ na develop \u2192 deploy do backend-api-staging\n\npush do frontend/ na master  \u2192 GCS app.kamilos.xyz\npush do frontend/ na develop \u2192 GCS staging.kamilos.xyz (z podmian\u0105 API_URL)\n</code></pre> <pre><code># deploy-backend.yml \u2014 branch-aware deploy\nenv:\n  SERVICE_NAME: ${{ github.ref_name == 'develop' &amp;&amp; 'backend-api-staging' || 'backend-api' }}\n</code></pre> <pre><code># deploy-frontend.yml \u2014 osobne steps per branch\n- name: Deploy to prod (master)\n  if: github.ref_name == 'master'\n  run: gcloud storage cp ... gs://app.kamilos.xyz/\n\n- name: Deploy to staging (develop)\n  if: github.ref_name == 'develop'\n  run: |\n    # Pobierz URL staging API Gateway\n    STAGING_HOSTNAME=$(gcloud api-gateway gateways describe gpc-gateway-staging ...)\n\n    # Podmie\u0144 URL w app.js (sed, bez commitowania)\n    sed \"s|const API_URL = '.*'|const API_URL = 'https://${STAGING_HOSTNAME}'|\" \\\n      frontend/app.js &gt; /tmp/app.staging.js\n\n    gcloud storage cp /tmp/app.staging.js gs://staging.kamilos.xyz/app.js\n</code></pre>"},{"location":"guide/10-staging/#workflow-testowania","title":"Workflow testowania","text":"<pre><code>1. Stw\u00f3rz feature branch z develop\n   git checkout -b feature/my-feature develop\n\n2. Zaimplementuj zmian\u0119 (app/ lub frontend/)\n\n3. Otw\u00f3rz PR do develop\n   gh pr create --base develop\n\n4. Po merge do develop \u2014 auto-deploy staging\n   \u2192 https://staging.kamilos.xyz\n\n5. Przetestuj na staging\n\n6. Otw\u00f3rz PR develop \u2192 master\n\n7. Po merge do master \u2014 auto-deploy prod\n   \u2192 https://app.kamilos.xyz\n</code></pre>"},{"location":"guide/10-staging/#puapki","title":"Pu\u0142apki","text":"<p>Staging API Gateway URL \u2014 chicken-and-egg</p> <p><code>deploy-frontend.yml</code> dla staging pobiera URL staging API Gateway przez <code>gcloud api-gateway gateways describe</code>. Je\u015bli gateway staging nie istnieje jeszcze (nie by\u0142 deployowany przez <code>deploy.yml</code>), workflow wywali si\u0119 z <code>NOT_FOUND</code>. Kolejno\u015b\u0107: najpierw deploy <code>api-gateway</code> layer przez <code>deploy.yml</code>, potem push do develop.</p> <p>Wsp\u00f3lny Cloud Run SA dla prod i staging</p> <p><code>cloud-run-backend-sa</code> jest u\u017cywany przez oba Cloud Run services. Je\u015bli musisz da\u0107 staging SA mniej uprawnie\u0144 \u2014 stw\u00f3rz osobny SA. Dla prototypu: jedna SA dla obu \u015brodowisk jest OK.</p> <p>Cloudflare \u2014 staging.kamilos.xyz wymaga orange cloud</p> <p>Tak samo jak app.kamilos.xyz \u2014 Cloudflare proxy musi by\u0107 ON (orange cloud) dla staging, \u017ceby HTTPS dzia\u0142a\u0142. Grey cloud (DNS only) = GCS bez SSL na custom domenie = \"not secure\" w przegl\u0105darce.</p> <p>Labels dla zasob\u00f3w staging</p> <p>Wszystkie zasoby staging maj\u0105 <code>labels = { env = \"staging\" }</code>. Pozwala to filtrowa\u0107 koszty i zasoby: <pre><code># Wszystkie Cloud Run services staging\ngcloud run services list --filter=\"metadata.labels.env=staging\"\n</code></pre></p>"},{"location":"guide/11-monitoring/","title":"Monitoring \u2014 alerty jako kod","text":"<p>Aplikacja bez monitoringu to aplikacja, w kt\u00f3rej awarie wykrywaj\u0105 u\u017cytkownicy. Cloud Monitoring z dashboardem, alertami i notyfikacjami email \u2014 wszystko jako kod Terraform.</p>"},{"location":"guide/11-monitoring/#co-monitorujemy","title":"Co monitorujemy","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  GPC Dashboard                                               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 API GW         \u2502 Cloud Run     \u2502 Cloud Run      \u2502 Cloud Run  \u2502\n\u2502 req/min        \u2502 latency p99   \u2502 5xx errors/min \u2502 instances  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Firestore reads/s              \u2502 Firestore writes/s          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500-\u2518\n\nAlerty:\n  \u2192 5xx errors &gt; 5 w 5 min    \u2192 email\n  \u2192 latency p99 &gt; 3s przez 5 min \u2192 email\n</code></pre>"},{"location":"guide/11-monitoring/#terraform-warstwa-tfmonitoring","title":"Terraform \u2014 warstwa <code>tf/monitoring/</code>","text":""},{"location":"guide/11-monitoring/#notification-channel-email","title":"Notification channel \u2014 email","text":"<pre><code>resource \"google_monitoring_notification_channel\" \"email\" {\n  display_name = \"GPC Alerts \u2014 email\"\n  type         = \"email\"\n\n  labels = {\n    email_address = var.alert_email  # przekazywany przez TF_VAR_alert_email w CI\n  }\n}\n</code></pre>"},{"location":"guide/11-monitoring/#alert-5xx-errors","title":"Alert \u2014 5xx errors","text":"<pre><code>resource \"google_monitoring_alert_policy\" \"alert_5xx\" {\n  display_name = \"GPC \u2014 HTTP 5xx errors (&gt;5/5min)\"\n  combiner     = \"OR\"\n\n  conditions {\n    display_name = \"Cloud Run backend-api \u2014 5xx count\"\n\n    condition_threshold {\n      filter = join(\" AND \", [\n        \"metric.type=\\\"run.googleapis.com/request_count\\\"\",\n        \"resource.type=\\\"cloud_run_revision\\\"\",\n        \"resource.labels.service_name=\\\"backend-api\\\"\",\n        \"metric.labels.response_code_class=\\\"5xx\\\"\",\n      ])\n\n      comparison      = \"COMPARISON_GT\"\n      threshold_value = 5         # (1)\n      duration        = \"0s\"      # (2)\n\n      aggregations {\n        alignment_period     = \"300s\"  # okno 5 minut\n        per_series_aligner   = \"ALIGN_SUM\"\n        cross_series_reducer = \"REDUCE_SUM\"\n        group_by_fields      = []\n      }\n\n      trigger {\n        count = 1\n      }\n    }\n  }\n\n  notification_channels = [google_monitoring_notification_channel.email.name]\n}\n</code></pre> <ol> <li><code>threshold_value = 5</code> \u2014 alert po 5 b\u0142\u0119dach 5xx w oknie 5 minut. Jeden b\u0142\u0105d 5xx (np. cold start timeout) nie wysy\u0142a alertu.</li> <li><code>duration = \"0s\"</code> \u2014 warunek musi by\u0107 spe\u0142niony przez 0 sekund przed alertem. W kombinacji z <code>alignment_period = 300s</code>: suma za ostatnie 5 minut &gt; 5 \u2192 alert. Gdyby <code>duration = \"300s\"</code> i <code>alignment_period = \"300s\"</code> \u2014 alert tylko je\u015bli przez 10 minut &gt; 5 b\u0142\u0119d\u00f3w.</li> </ol>"},{"location":"guide/11-monitoring/#alert-latency-p99","title":"Alert \u2014 latency p99","text":"<pre><code>resource \"google_monitoring_alert_policy\" \"alert_latency\" {\n  display_name = \"GPC \u2014 Cloud Run latency p99 &gt; 3s\"\n\n  conditions {\n    condition_threshold {\n      filter = join(\" AND \", [\n        \"metric.type=\\\"run.googleapis.com/request_latencies\\\"\",\n        \"resource.type=\\\"cloud_run_revision\\\"\",\n        \"resource.labels.service_name=\\\"backend-api\\\"\",\n      ])\n\n      comparison      = \"COMPARISON_GT\"\n      threshold_value = 3000      # milisekundy\n      duration        = \"300s\"    # przez 5 minut ci\u0105g\u0142e\n\n      aggregations {\n        alignment_period     = \"300s\"\n        per_series_aligner   = \"ALIGN_PERCENTILE_99\"  # (1)\n        cross_series_reducer = \"REDUCE_MEAN\"\n      }\n    }\n  }\n}\n</code></pre> <ol> <li><code>ALIGN_PERCENTILE_99</code> \u2014 99. percentyl latency. Nie \u015brednia (kt\u00f3ra maskuje outliery). Je\u015bli 99% request\u00f3w odpowiada &lt; 3s przez 5 minut \u2014 alert. U\u017cytkownicy z powolnymi po\u0142\u0105czeniami nie triggeruj\u0105 fa\u0142szywych alert\u00f3w.</li> </ol>"},{"location":"guide/11-monitoring/#budget-alert-opcjonalny","title":"Budget alert \u2014 opcjonalny","text":"<pre><code>resource \"google_billing_budget\" \"monthly\" {\n  count           = var.billing_account_id != \"\" ? 1 : 0  # (1)\n  billing_account = var.billing_account_id\n\n  budget_filter {\n    projects = [\"projects/${var.project_id}\"]\n  }\n\n  amount {\n    specified_amount {\n      currency_code = \"USD\"\n      units         = tostring(var.monthly_budget_usd)\n    }\n  }\n\n  threshold_rules {\n    threshold_percent = 0.5   # 50% bud\u017cetu\n  }\n  threshold_rules {\n    threshold_percent = 0.8   # 80% bud\u017cetu\n  }\n  threshold_rules {\n    threshold_percent = 1.0\n    spend_basis       = \"FORECASTED_SPEND\"  # prognoza przekroczy limit\n  }\n\n  all_updates_rule {\n    monitoring_notification_channels = [google_monitoring_notification_channel.email.name]\n    schema_version                   = \"1.0\"\n  }\n}\n</code></pre> <ol> <li><code>count = var.billing_account_id != \"\" ? 1 : 0</code> \u2014 zas\u00f3b tworzony tylko gdy <code>billing_account_id</code> jest podany. Wymagane uprawnienia: <code>billing.budgetsAdmin</code> na billing account. Bez uprawnie\u0144: ustaw <code>GCP_BILLING_ACCOUNT_ID = \"\"</code> (lub nie ustawiaj) w GitHub Secrets.</li> </ol>"},{"location":"guide/11-monitoring/#dashboard-json-w-terraform","title":"Dashboard \u2014 JSON w Terraform","text":"<pre><code>resource \"google_monitoring_dashboard\" \"gpc\" {\n  dashboard_json = jsonencode({\n    displayName = \"GPC Dashboard\"\n    gridLayout = {\n      columns = \"2\"\n      widgets = [\n        {\n          title = \"API Gateway \u2014 req/min\"\n          xyChart = {\n            dataSets = [{\n              timeSeriesQuery = {\n                timeSeriesFilter = {\n                  filter = \"metric.type=\\\"apigateway.googleapis.com/http/request_count\\\"\"\n                  aggregation = {\n                    alignmentPeriod    = \"60s\"\n                    perSeriesAligner   = \"ALIGN_RATE\"\n                    crossSeriesReducer = \"REDUCE_SUM\"\n                  }\n                }\n              }\n            }]\n          }\n        },\n        # ... pozosta\u0142e widgety (Cloud Run latency, 5xx, instances, Firestore)\n      ]\n    }\n  })\n}\n</code></pre> <p>Dashboard jako kod \u2014 wersjonowany, powtarzalny, widoczny w code review.</p>"},{"location":"guide/11-monitoring/#metryki-kluczowe","title":"Metryki kluczowe","text":"Metryka Typ Gdzie <code>apigateway.googleapis.com/http/request_count</code> Counter API Gateway <code>run.googleapis.com/request_latencies</code> Distribution Cloud Run <code>run.googleapis.com/request_count</code> Counter Cloud Run (z <code>response_code_class</code>) <code>run.googleapis.com/container/instance_count</code> Gauge Cloud Run (aktywne instancje) <code>firestore.googleapis.com/document/read_count</code> Counter Firestore <code>firestore.googleapis.com/document/write_count</code> Counter Firestore"},{"location":"guide/11-monitoring/#free-tier-cloud-monitoring","title":"Free tier Cloud Monitoring","text":"Metryka Limit Free tier Metryki ingested 150 MB/mies Custom metrics Nie dotyczy (u\u017cywamy system metrics) Alert policies Unlimited Dashboard Unlimited Log-based metrics 50 user-defined <p>Dla tego projektu: wszystkie metryki s\u0105 system metrics (GCP zbiera je automatycznie). Free tier w pe\u0142ni wystarczy.</p>"},{"location":"guide/11-monitoring/#puapki","title":"Pu\u0142apki","text":"<p>disable_default_iam_alerts \u2014 usuni\u0119te w Google provider v5</p> <p>Starsze przyk\u0142ady z internetu zawieraj\u0105 <code>disable_default_iam_alerts = true</code> w <code>all_updates_rule</code>. W Google Terraform Provider v5 to pole zosta\u0142o usuni\u0119te. Dodanie go zwr\u00f3ci b\u0142\u0105d.</p> <p>Eksportowanie dashboardu do JSON</p> <p>Je\u015bli zmodyfikujesz dashboard r\u0119cznie w konsoli i chcesz zapisa\u0107 zmiany do TF: <pre><code>gcloud monitoring dashboards describe DASHBOARD_ID --format=json\n</code></pre> Skopiuj pole <code>gridLayout</code> do <code>dashboard_json</code> w TF.</p>"},{"location":"guide/12-security/","title":"Security Review \u2014 checklist","text":"<p>Security review to systematyczne przej\u015bcie przez ka\u017cd\u0105 warstw\u0119 architektury pod k\u0105tem bezpiecze\u0144stwa. Robimy to po ka\u017cdej zmianie Terraform, przed ka\u017cdym apply.</p>"},{"location":"guide/12-security/#dlaczego-security-review-jako-kod","title":"Dlaczego security review jako kod?","text":"<p>Wi\u0119kszo\u015b\u0107 projekt\u00f3w ma security review jako slajdy PowerPoint, kt\u00f3re nikt nie czyta. My mamy checklist jako <code>/sec-review</code> \u2014 uruchamiasz przed deployem, dostajesz raport. Zasady nie istniej\u0105 dop\u00f3ki nie s\u0105 testowalne.</p>"},{"location":"guide/12-security/#checklist-warstwa-po-warstwie","title":"Checklist \u2014 warstwa po warstwie","text":""},{"location":"guide/12-security/#iam","title":"IAM","text":"<pre><code>\u2705 SA nie maj\u0105 roles/owner ani roles/editor\n\u2705 gh-infra-worker: roles/iam.securityAdmin (nie projectIamAdmin)\n\u2705 cloud-run-backend-sa: tylko logging.logWriter + datastore.user\n\u2705 api-gateway-sa: tylko roles/run.invoker (na konkretnym service, nie na projekcie)\n\u2705 Brak tworzenia SA keys \u2014 wszystko przez WIF lub ADC\n</code></pre> <p>Zasada: ka\u017cde SA ma minimalny zestaw r\u00f3l potrzebnych do dzia\u0142ania. Nic wi\u0119cej.</p> <p>Dlaczego <code>iam.securityAdmin</code> zamiast <code>resourcemanager.projectIamAdmin</code>?</p> <pre><code>projectIamAdmin:\n  - mo\u017ce nadawa\u0107 WSZYSTKIE role na projekcie\n  - je\u015bli gh-infra-worker zostanie skompromitowany \u2192 attacker ma god mode\n\niam.securityAdmin:\n  - mo\u017ce nadawa\u0107 role, ale tylko te kt\u00f3re sam posiada\n  - w\u0119\u017cszy blast radius przy kompromitacji\n</code></pre>"},{"location":"guide/12-security/#cloud-run","title":"Cloud Run","text":"<pre><code>\u2705 ingress = INGRESS_TRAFFIC_ALL (wymagane \u2014 API Gateway nie jest LB)\n\u2705 IAM isolacja: tylko api-gateway-sa ma roles/run.invoker\n\u2705 VPC Connector \u2014 egress przez prywatn\u0105 sie\u0107\n\u2705 SA: cloud-run-backend-sa (nie default Compute SA)\n\u26a0\ufe0f  min_instance_count = 0 (cold start, ale nie security issue)\n</code></pre> <p>Cloud Run z <code>ingress=ALL</code> jest technicznie dost\u0119pny z internetu. Ochrona: 1. Brak <code>allUsers</code> w IAM \u2192 403 bez tokenu 2. Brak <code>allAuthenticatedUsers</code> \u2192 tylko <code>api-gateway-sa</code> mo\u017ce wywo\u0142a\u0107</p> <pre><code># Test: wywo\u0142anie Cloud Run bez tokenu\ncurl -si https://backend-api-mngq3uouha-lm.a.run.app/api\n# Oczekiwane: 403 Forbidden\n</code></pre>"},{"location":"guide/12-security/#siec","title":"Sie\u0107","text":"<pre><code>\u2705 VPC: auto_create_subnetworks = false\n\u2705 Firewall: deny-all ingress (priority 65534) \u2014 eksplicytna dokumentacja intent\n\u2705 private_ip_google_access = true \u2014 bez publicznych IP dla zasob\u00f3w VPC\n\u2705 VPC Connector: oddzielna podsie\u0107 10.8.0.0/28\n</code></pre>"},{"location":"guide/12-security/#secrets-management","title":"Secrets Management","text":"<pre><code>\u2705 OAuth credentials w Secret Manager (nie w plaintext TF zmiennych)\n\u2705 TF zmienne sensitive=true dla credentiali\n\u2705 GitHub Secrets \u2014 nie repozytoria kluczy SA\n\u2705 \u017badnych sekret\u00f3w w kodzie (app.js apiKey jest publiczny z za\u0142o\u017cenia)\n\u2705 State bucket: public_access_prevention = enforced\n</code></pre> <pre><code># DOBRZE: Secret Manager\nresource \"google_secret_manager_secret_version\" \"oauth_secret\" {\n  secret_data = var.google_oauth_client_secret  # sensitive var\n}\n\n# \u0179LE: plaintext w output\noutput \"oauth_secret\" {\n  value = var.google_oauth_client_secret  # NIGDY NIE R\u00d3B TEGO\n}\n</code></pre>"},{"location":"guide/12-security/#api-gateway","title":"API Gateway","text":"<pre><code>\u2705 Wszystkie \u015bcie\u017cki maj\u0105 security: - firebase: []\n\u2705 OPTIONS (CORS preflight) ma security: [] (wymagane \u2014 preflight nie ma JWT)\n\u2705 JWT walidowany: issuer, audience, podpis, expiry\n\u2705 Backend SA: api-gateway-sa (nie default SA)\n</code></pre>"},{"location":"guide/12-security/#storage","title":"Storage","text":"<pre><code>\u2705 State bucket: public_access_prevention = enforced (wymagane)\n\u26a0\ufe0f  Frontend buckets: public_access_prevention = unspecified + allUsers objectViewer\n    \u2192 celowe \u2014 hosting publicznej SPA. Tylko czytanie obiekt\u00f3w, nie zarz\u0105dzanie.\n</code></pre> <p>R\u00f3\u017cnica mi\u0119dzy state bucket a frontend bucket:</p> <pre><code># State bucket \u2014 musi by\u0107 prywatny\nresource \"google_storage_bucket\" \"tf_state\" {\n  public_access_prevention = \"enforced\"  # \u2705\n}\n\n# Frontend bucket \u2014 publiczny SPA hosting\nresource \"google_storage_bucket\" \"frontend\" {\n  public_access_prevention = \"unspecified\"  # (1)\n}\nresource \"google_storage_bucket_iam_member\" \"public_read\" {\n  role   = \"roles/storage.objectViewer\"  # tylko czytanie plik\u00f3w\n  member = \"allUsers\"\n}\n</code></pre> <ol> <li><code>unspecified</code> bo <code>enforced</code> blokowa\u0142oby <code>allUsers</code> IAM binding. Nie u\u017cywamy <code>inherited</code> (dziedziczy\u0142oby z org policy).</li> </ol>"},{"location":"guide/12-security/#service-account-keys","title":"Service Account Keys","text":"<pre><code>\u2705 Brak tworzenia SA keys w ca\u0142ym TF (google_service_account_key)\n\u2705 CI/CD: WIF (keyless) \u2014 tymczasowe tokeny, wa\u017cne 1h\n\u2705 Lokalne: gcloud ADC (user credentials) lub impersonacja SA\n</code></pre> <p>Je\u015bli znajdziesz <code>google_service_account_key</code> w jakimkolwiek TF pliku \u2014 usu\u0144 natychmiast.</p>"},{"location":"guide/12-security/#swiadome-kompromisy-bezpieczenstwa","title":"\u015awiadome kompromisy bezpiecze\u0144stwa","text":"<p>Nie wszystko jest idealne \u2014 to s\u0105 \u015bwiadome decyzje z udokumentowanym uzasadnieniem:</p> Kompromis Pow\u00f3d \u015acie\u017cka upgrade <code>ingress=ALL</code> na Cloud Run API Gateway nie jest LB Private Service Connect (kompleks) <code>datastore.owner</code> dla gh-infra-worker <code>datastore.admin</code> niedost\u0119pny na poziomie projektu Brak prostszej alternatywy w GCP JWT decode bez weryfikacji w FastAPI API Gateway ju\u017c weryfikuje; backend chroniony IAM Doda\u0107 <code>python-jose</code> je\u015bli defence-in-depth wymagane Jeden SA dla Cloud Run prod+staging Uproszczenie Osobne SA per env"},{"location":"guide/12-security/#puapki","title":"Pu\u0142apki","text":"<p>State Terraform zawiera wra\u017cliwe dane</p> <p><code>terraform.tfstate</code> mo\u017ce zawiera\u0107: endpointy Cloud Run, SA emails, czasem warto\u015bci zmiennych. State bucket musi mie\u0107 <code>public_access_prevention = enforced</code> i dost\u0119p tylko dla <code>gh-infra-worker</code> i w\u0142asnych admin\u00f3w.</p> <p>Terraform output sensitive=false</p> <p>Nigdy nie dodawaj do <code>outputs.tf</code> warto\u015bci takich jak <code>client_secret</code>, klucze, tokeny bez <code>sensitive = true</code>. Outputs s\u0105 widoczne w logach GitHub Actions.</p> <p>Security review przed ka\u017cdym PR</p> <p>Uruchom <code>/sec-review</code> przed merge PR zawieraj\u0105cego zmiany w <code>tf/</code>. W tym projekcie jest to skill Claude Code \u2014 wykonuje automatyczn\u0105 weryfikacj\u0119 wszystkich powy\u017cszych punkt\u00f3w na podstawie <code>git diff</code>.</p>"},{"location":"guide/13-cost-analysis/","title":"Analiza koszt\u00f3w","text":"<p>Koszty to pierwszorz\u0119dna decyzja architektoniczna \u2014 ka\u017cda warstwa by\u0142a wybierana z uwzgl\u0119dnieniem koszt\u00f3w przy niskim ruchu.</p>"},{"location":"guide/13-cost-analysis/#rzeczywisty-koszt-tej-architektury","title":"Rzeczywisty koszt tej architektury","text":"Komponent Koszt/mies Model rozliczenia Uwagi VPC Connector ~$7.00 Sta\u0142y (reserved capacity) Najwi\u0119kszy koszt. min_throughput=200Mbps Cloud Run $0\u20130.50 Per request + per vCPU-sec $0.00002400/vCPU-s, $0.00000250/GB-s API Gateway $0\u20130.03 Per million calls Free: 2M calls/mies Firestore $0 Per read/write/storage Free: 50k reads/dzie\u0144, 20k writes/dzie\u0144, 1GB GCS buckets ~$0.05 Per GB storage + egress 0.026 USD/GB/mies EU multi-region Artifact Registry ~$0.10 Per GB storage 0.10 USD/GB/mies powy\u017cej 0.5GB free Cloud Monitoring $0 Per MB ingested Free: 150 MB/mies system metrics Cloudflare CDN $0 Free tier Bez limitu bandwidth Secret Manager ~$0.06 Per secret version + access $0.06/version/mies, $0.03/10k access \u0141\u0105cznie ~$7\u20138/mies Praktycznie tylko VPC Connector"},{"location":"guide/13-cost-analysis/#gdzie-jest-free-tier","title":"Gdzie jest Free tier","text":""},{"location":"guide/13-cost-analysis/#cloud-run-prawie-zawsze-0","title":"Cloud Run \u2014 prawie zawsze $0","text":"<pre><code>Miesi\u0119czny free tier Cloud Run:\n  - 2,000,000 request\u00f3w\n  - 360,000 GB-sekund pami\u0119ci RAM\n  - 180,000 vCPU-sekund\n\nPrzy 1000 request\u00f3w/dzie\u0144 \u00d7 30 dni = 30,000 req/mies\n  \u2192 daleko poni\u017cej 2M free tier\n  \u2192 $0\n</code></pre>"},{"location":"guide/13-cost-analysis/#api-gateway-prawie-zawsze-0","title":"API Gateway \u2014 prawie zawsze $0","text":"<pre><code>Free tier: 2,000,000 calls/mies (pierwsze 12 miesi\u0119cy)\nPo free tier: $3.50 per million calls\n\nPrzy 1000 req/dzie\u0144 = 30,000/mies \u2192 $0 (free tier)\nPrzy 100k req/dzie\u0144 = 3M/mies \u2192 $3.50 (po free tier)\n</code></pre>"},{"location":"guide/13-cost-analysis/#firestore-0-przy-niskim-ruchu","title":"Firestore \u2014 $0 przy niskim ruchu","text":"<pre><code>Free tier (Spark plan, bez limitu czasu):\n  - 50,000 document reads/dzie\u0144\n  - 20,000 document writes/dzie\u0144\n  - 20,000 document deletes/dzie\u0144\n  - 1 GB storage\n\nPrzy 100 user\u00f3w \u00d7 2 logins/dzie\u0144:\n  - 200 reads + 200 writes \u2192 0.4% free tier\n  \u2192 $0\n</code></pre>"},{"location":"guide/13-cost-analysis/#co-kosztuje-7mies-vpc-connector","title":"Co kosztuje $7/mies (VPC Connector)","text":"<p>VPC Connector to jedyny sta\u0142y koszt \u2014 niezale\u017cny od ruchu.</p> <pre><code>Cena: $0.010/h (200 Mbps minimum)\nPrzy pe\u0142nym miesi\u0105cu: $0.010 \u00d7 24h \u00d7 30 dni = $7.20/mies\n\nUwaga: throughput 200-300 Mbps to RESERVED capacity,\nnie faktyczne u\u017cycie. P\u0142acisz za gotowo\u015b\u0107,\nnawet przy 0 requestach.\n</code></pre> <p>Alternatywa bez VPC Connectora: Firestore przez publiczne API, bez VPC. Koszt = ~$0/mies. Kompromis: brak sieci prywatnej, Cloud Run komunikuje si\u0119 z Firestore przez internet (szyfrowany, ale publiczny).</p> <pre><code># Bez VPC Connector \u2014 usun\u0105\u0107 z Cloud Run template:\n# vpc_access { ... }\n# I usun\u0105\u0107 VPC Connector resource z backend/main.tf\n</code></pre>"},{"location":"guide/13-cost-analysis/#koszt-przy-skalowaniu","title":"Koszt przy skalowaniu","text":"Ruch Req/mies Cloud Run API Gateway Firestore \u0141\u0105cznie Prototyp 30K $0 $0 $0 $7 (VPC) Ma\u0142y startup 500K ~$0.50 $0 ~$0.20 $8 Rosn\u0105cy produkt 5M ~$5 ~$10.50 ~$2 $25 Scale-up 50M ~$50 ~$140 ~$20 $220 <p>Przy 5M requestach miesi\u0119cznie (~170k/dzie\u0144): $25/mies. To punkt gdzie warto rozwa\u017cy\u0107 optymalizacje (cache, min-instances, batching).</p>"},{"location":"guide/13-cost-analysis/#koszt-vs-alternatywy","title":"Koszt vs alternatywy","text":""},{"location":"guide/13-cost-analysis/#gdybysmy-wybrali-google-global-load-balancer-cdn-cloud-armor","title":"Gdyby\u015bmy wybrali Google Global Load Balancer + CDN + Cloud Armor","text":"<pre><code>Google Cloud Load Balancing: ~$18/mies (forwarding rules + ingress)\nCloud CDN:                   ~$2/mies (minimal traffic)\nCloud Armor (Security tier): ~$5/mies (minimum)\n\u0141\u0105cznie:                     ~$25/mies\n\nVs Cloudflare Free:          $0/mies\nOszcz\u0119dno\u015b\u0107:                 ~$25/mies = ~$300/rok\n</code></pre>"},{"location":"guide/13-cost-analysis/#gdybysmy-wybrali-gke-autopilot","title":"Gdyby\u015bmy wybrali GKE Autopilot","text":"<pre><code>GKE Autopilot minimum:  ~$70/mies (cluster management fee)\nNode pool (2 vCPU):     ~$50/mies\n\u0141\u0105cznie:                ~$120/mies\n\nVs Cloud Run:           $0\u2013$0.50/mies\nOszcz\u0119dno\u015b\u0107:            ~$120/mies = ~$1,440/rok\n</code></pre>"},{"location":"guide/13-cost-analysis/#gdybysmy-wybrali-cloud-sql-zamiast-firestore","title":"Gdyby\u015bmy wybrali Cloud SQL zamiast Firestore","text":"<pre><code>Cloud SQL db-f1-micro:  ~$7/mies (zawsze uruchomiona)\nStorage 10GB SSD:       ~$1.70/mies\nBackup:                 ~$0.50/mies\n\u0141\u0105cznie:                ~$9/mies\n\nVs Firestore:           $0/mies\nOszcz\u0119dno\u015b\u0107:            ~$9/mies = ~$108/rok\n</code></pre>"},{"location":"guide/13-cost-analysis/#monitoring-kosztow","title":"Monitoring koszt\u00f3w","text":""},{"location":"guide/13-cost-analysis/#billing-budget-jesli-masz-uprawnienia","title":"Billing budget (je\u015bli masz uprawnienia)","text":"<pre><code># tf/monitoring/main.tf\nresource \"google_billing_budget\" \"monthly\" {\n  count           = var.billing_account_id != \"\" ? 1 : 0\n  billing_account = var.billing_account_id\n\n  amount {\n    specified_amount {\n      currency_code = \"USD\"\n      units         = \"20\"  # $20/mies limit\n    }\n  }\n\n  threshold_rules {\n    threshold_percent = 0.5   # alert przy $10\n  }\n  threshold_rules {\n    threshold_percent = 1.0\n    spend_basis       = \"FORECASTED_SPEND\"  # prognoza przekroczy limit\n  }\n}\n</code></pre>"},{"location":"guide/13-cost-analysis/#reczny-monitoring","title":"R\u0119czny monitoring","text":"<pre><code># Bie\u017c\u0105cy koszt miesi\u0105ca\ngcloud beta billing projects describe PROJECT_ID\n\n# Szczeg\u00f3\u0142owy breakdown w konsoli\n# \u2192 GCP Console \u2192 Billing \u2192 Cost breakdown \u2192 per service\n</code></pre>"},{"location":"guide/13-cost-analysis/#sciezki-optymalizacji-kosztow","title":"\u015acie\u017cki optymalizacji koszt\u00f3w","text":"Gdy... Rozwa\u017c... Oszcz\u0119dno\u015b\u0107 Ruch wzro\u015bnie powy\u017cej Free tier API GW Cache responses w Cloudflare 50-80% mniej API calls Cold start jest problemem <code>min_instance_count = 1</code> +$7/mies, -cold start Ruch wyra\u017anie dobowy <code>max_instance_count = 1</code> w nocy nieistotne przy min=0 Du\u017co Firestore reads Agregacja w Cloud Run (cache w pami\u0119ci) Redukcja reads VPC za drogi przy ma\u0142ym projekcie Usu\u0144 VPC Connector, Firestore przez publiczne API -$7/mies"}]}